(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var VNode = require('./vnode');
var is = require('./is');

module.exports = function h(sel, b, c) {
  var data = {}, children, text, i;
  if (arguments.length === 3) {
    data = b;
    if (is.array(c)) { children = c; }
    else if (is.primitive(c)) { text = c; }
  } else if (arguments.length === 2) {
    if (is.array(b)) { children = b; }
    else if (is.primitive(b)) { text = b; }
    else { data = b; }
  }
  if (is.array(children)) {
    for (i = 0; i < children.length; ++i) {
      if (is.primitive(children[i])) children[i] = VNode(undefined, undefined, undefined, children[i]);
    }
  }
  return VNode(sel, data, children, text, undefined);
};

},{"./is":3,"./vnode":17}],2:[function(require,module,exports){
function pre(vnode, newVnode) {
  var attachData = vnode.data.attachData;
  // Copy created placeholder and real element from old vnode
  newVnode.data.attachData.placeholder = attachData.placeholder;
  newVnode.data.attachData.real = attachData.real;
  // Mount real element in vnode so the patch process operates on it
  vnode.elm = vnode.data.attachData.real;
}

function post(_, vnode) {
  // Mount dummy placeholder in vnode so potential reorders use it
  vnode.elm = vnode.data.attachData.placeholder;
}

function destroy(vnode) {
  // Remove real element from where it was inserted
  var attachData = vnode.data.attachData;
  attachData.target.removeChild(attachData.real);
}

function create(_, vnode) {
  var real = vnode.elm, attachData = vnode.data.attachData;
  var placeholder = document.createElement('span');
  // Replace actual element with dummy placeholder
  // Snabbdom will then insert placeholder instead
  vnode.elm = placeholder;
  attachData.target.appendChild(real);
  attachData.real = real;
  attachData.placeholder = placeholder;
}

module.exports = function(target, vnode) {
  if (vnode.data === undefined) vnode.data = {};
  if (vnode.data.hook === undefined) vnode.data.hook = {};
  var data = vnode.data;
  var hook = vnode.data.hook;
  data.attachData = {target: target, placeholder: undefined, real: undefined};
  hook.create = create;
  hook.prepatch = pre;
  hook.postpatch = post;
  hook.destroy = destroy;
  return vnode;
};

},{}],3:[function(require,module,exports){
module.exports = {
  array: Array.isArray,
  primitive: function(s) { return typeof s === 'string' || typeof s === 'number'; },
};

},{}],4:[function(require,module,exports){
function updateClass(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldClass = oldVnode.data.class || {},
      klass = vnode.data.class || {};
  for (name in klass) {
    cur = klass[name];
    if (cur !== oldClass[name]) {
      elm.classList[cur ? 'add' : 'remove'](name);
    }
  }
}

module.exports = {create: updateClass, update: updateClass};

},{}],5:[function(require,module,exports){
var is = require('../is');

function arrInvoker(arr) {
  return function() { arr[0](arr[1]); };
}

function fnInvoker(arr) {
  return function(ev) { arr[0](ev); };
}

function updateEventListeners(oldVnode, vnode) {
  var name, cur, old, elm = vnode.elm,
      oldOn = oldVnode.data.on || {}, on = vnode.data.on;
  if (!on) return;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    if (old === undefined) {
      if (is.array(cur)) {
        elm.addEventListener(name, arrInvoker(cur));
      } else {
        cur = [cur];
        on[name] = cur;
        elm.addEventListener(name, fnInvoker(cur));
      }
    } else if (old.length === 2) {
      old[0] = cur[0]; // Deliberately modify old array since it's
      old[1] = cur[1]; // captured in closure created with `arrInvoker`
      on[name]  = old;
    } else {
      old[0] = cur;
      on[name] = old;
    }
  }
}

module.exports = {create: updateEventListeners, update: updateEventListeners};

},{"../is":3}],6:[function(require,module,exports){
function updateProps(oldVnode, vnode) {
  var key, cur, old, elm = vnode.elm,
      oldProps = oldVnode.data.props || {}, props = vnode.data.props || {};
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur) {
      elm[key] = cur;
    }
  }
}

module.exports = {create: updateProps, update: updateProps};

},{}],7:[function(require,module,exports){
var raf = requestAnimationFrame || setTimeout;
var nextFrame = function(fn) { raf(function() { raf(fn); }); };

function setNextFrame(obj, prop, val) {
  nextFrame(function() { obj[prop] = val; });
}

function updateStyle(oldVnode, vnode) {
  var cur, name, elm = vnode.elm,
      oldStyle = oldVnode.data.style || {},
      style = vnode.data.style || {},
      oldHasDel = 'delayed' in oldStyle;
  for (name in style) {
    cur = style[name];
    if (name === 'delayed') {
      for (name in style.delayed) {
        cur = style.delayed[name];
        if (!oldHasDel || cur !== oldStyle.delayed[name]) {
          setNextFrame(elm.style, name, cur);
        }
      }
    } else if (name !== 'remove' && cur !== oldStyle[name]) {
      elm.style[name] = cur;
    }
  }
}

function applyDestroyStyle(vnode) {
  var style, name, elm = vnode.elm, s = vnode.data.style;
  if (!s || !(style = s.destroy)) return;
  for (name in style) {
    elm.style[name] = style[name];
  }
}

function applyRemoveStyle(vnode, rm) {
  var s = vnode.data.style;
  if (!s || !s.remove) {
    rm();
    return;
  }
  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,
      compStyle, style = s.remove, amount = 0;
  var applied = [];
  for (name in style) {
    applied.push(name);
    elm.style[name] = style[name];
  }
  compStyle = getComputedStyle(elm);
  var props = compStyle['transition-property'].split(', ');
  for (; i < props.length; ++i) {
    if(applied.indexOf(props[i]) !== -1) amount++;
  }
  elm.addEventListener('transitionend', function(ev) {
    if (ev.target === elm) --amount;
    if (amount === 0) rm();
  });
}

module.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};

},{}],8:[function(require,module,exports){
console.log('lol');
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory); // AMD. Register as an anonymous module.
  } else if (typeof exports === 'object') {
    module.exports = factory(); // NodeJS
  } else { // Browser globals (root is window)
  root.fakeRaf = factory();
  }
}(this, function () {

var original;

var requesters = [];

function fakeRaf(fn) {
  requesters.push(fn);
}

function use() {
  original = window.requestAnimationFrame;
  window.requestAnimationFrame = fakeRaf;
}

function restore() {
  window.requestAnimationFrame = original;
}

function step() {
  var cur = requesters;
  requesters = [];
  cur.forEach(function(f) { f(16); });
}

return {use: use, restore: restore, step: step};

}));

},{}],9:[function(require,module,exports){
(function (global){
/*jshint -W054 */
(function (exports) {
  'use strict';

  // http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
  function shuffle(array) {
    var currentIndex = array.length
      , temporaryValue
      , randomIndex
      ;

    // While there remain elements to shuffle...
    while (0 !== currentIndex) {

      // Pick a remaining element...
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex -= 1;

      // And swap it with the current element.
      temporaryValue = array[currentIndex];
      array[currentIndex] = array[randomIndex];
      array[randomIndex] = temporaryValue;
    }

    return array;
  }

  exports.knuthShuffle = shuffle;
}('undefined' !== typeof exports && exports || 'undefined' !== typeof window && window || global));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],10:[function(require,module,exports){
// jshint newcap: false
/* global require, module, document, Element */
'use strict';

var VNode = require('./vnode');
var is = require('./is');

function isUndef(s) { return s === undefined; }

function emptyNodeAt(elm) {
  return VNode(elm.tagName, {}, [], undefined, elm);
}

var emptyNode = VNode('', {}, [], undefined, undefined);

var insertedVnodeQueue;

function sameVnode(vnode1, vnode2) {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, map = {}, key;
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (!isUndef(key)) map[key] = i;
  }
  return map;
}

function createRmCb(parentElm, childElm, listeners) {
  return function() {
    if (--listeners === 0) parentElm.removeChild(childElm);
  };
}

var hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];

function init(modules) {
  var i, j, cbs = {};
  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);
    }
  }

  function createElm(vnode) {
    var i, data = vnode.data;
    if (!isUndef(data)) {
      if (!isUndef(i = data.hook) && !isUndef(i = i.init)) i(vnode);
      if (!isUndef(i = data.vnode)) vnode = i;
    }
    var elm, children = vnode.children, sel = vnode.sel;
    if (!isUndef(sel)) {
      // Parse selector
      var hashIdx = sel.indexOf('#');
      var dotIdx = sel.indexOf('.', hashIdx);
      var hash = hashIdx > 0 ? hashIdx : sel.length;
      var dot = dotIdx > 0 ? dotIdx : sel.length;
      var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      elm = vnode.elm = !isUndef(data) && !isUndef(i = data.ns) ? document.createElementNS(i, tag)
                                                                : document.createElement(tag);
      if (hash < dot) elm.id = sel.slice(hash + 1, dot);
      if (dotIdx > 0) elm.className = sel.slice(dot+1).replace(/\./g, ' ');
      if (is.array(children)) {
        for (i = 0; i < children.length; ++i) {
          elm.appendChild(createElm(children[i]));
        }
      } else if (is.primitive(vnode.text)) {
        elm.appendChild(document.createTextNode(vnode.text));
      }
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);
      i = vnode.data.hook; // Reuse variable
      if (!isUndef(i)) {
        if (i.create) i.create(emptyNode, vnode);
        if (i.insert) insertedVnodeQueue.push(vnode);
      }
    } else {
      elm = vnode.elm = document.createTextNode(vnode.text);
    }
    return vnode.elm;
  }

  function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      parentElm.insertBefore(createElm(vnodes[startIdx]), before);
    }
  }

  function invokeDestroyHook(vnode) {
    var i = vnode.data, j;
    if (!isUndef(i)) {
      if (!isUndef(i = i.hook) && !isUndef(i = i.destroy)) i(vnode);
      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
      if (!isUndef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var i, listeners, rm, ch = vnodes[startIdx];
      if (!isUndef(ch)) {
        invokeDestroyHook(ch);
        listeners = cbs.remove.length + 1;
        rm = createRmCb(parentElm, ch.elm, listeners);
        for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
        if (!isUndef(i = ch.data) && !isUndef(i = i.hook) && !isUndef(i = i.remove)) {
          i(ch, rm);
        } else {
          rm();
        }
      }
    }
  }

  function updateChildren(parentElm, oldCh, newCh) {
    var oldStartIdx = 0, newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, before;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode);
        parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling);
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode);
        parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        idxInOld = oldKeyToIdx[newStartVnode.key];
        if (isUndef(idxInOld)) { // New element
          parentElm.insertBefore(createElm(newStartVnode), oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          patchVnode(elmToMove, newStartVnode);
          oldCh[idxInOld] = undefined;
          parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      before = isUndef(newCh[newEndIdx+1]) ? null : newCh[newEndIdx+1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode) {
    var i, hook;
    if (!isUndef(i = vnode.data) && !isUndef(hook = i.hook) && !isUndef(i = hook.prepatch)) {
      i(oldVnode, vnode);
    }
    if (!isUndef(i = oldVnode.data) && !isUndef(i = i.vnode)) oldVnode = i;
    if (!isUndef(i = vnode.data) && !isUndef(i = i.vnode)) vnode = i;
    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;
    if (oldVnode === vnode) return;
    if (!isUndef(vnode.data)) {
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode);
      i = vnode.data.hook;
      if (!isUndef(i) && !isUndef(i = i.update)) i(oldVnode, vnode);
    }
    if (isUndef(vnode.text)) {
      if (!isUndef(oldCh) && !isUndef(ch)) {
        if (oldCh !== ch) updateChildren(elm, oldCh, ch);
      } else if (!isUndef(ch)) {
        addVnodes(elm, null, ch, 0, ch.length - 1);
      } else if (!isUndef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      }
    } else if (oldVnode.text !== vnode.text) {
      elm.textContent = vnode.text;
    }
    if (!isUndef(hook) && !isUndef(i = hook.postpatch)) {
      i(oldVnode, vnode);
    }
    return vnode;
  }

  return function(oldVnode, vnode) {
    var i;
    insertedVnodeQueue = [];
    if (oldVnode instanceof Element) {
      oldVnode = emptyNodeAt(oldVnode);
    }
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();
    patchVnode(oldVnode, vnode);
    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);
    }
    insertedVnodeQueue = undefined;
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i]();
    return vnode;
  };
}

module.exports = {init: init};

},{"./is":3,"./vnode":17}],11:[function(require,module,exports){
var assert = require('assert');
var snabbdom = require('../snabbdom');

var patch = snabbdom.init([]);
var attachTo = require('../helpers/attachto');
var h = require('../h');

describe('attachTo', function() {
  var elm, vnode0;
  beforeEach(function() {
    elm = document.createElement('div');
    vnode0 = elm;
  });
  it('adds element to target', function() {
    patch(vnode0, h('div', [
      h('div#wrapper', [
        h('div', 'Some element'),
        attachTo(elm, h('div#attached', 'Test')),
      ]),
    ]));
    assert.equal(elm.children.length, 2);
  });
  it('updates element at target', function() {
    var vnode1 = h('div', [
      h('div#wrapper', [
        h('div', 'Some element'),
        attachTo(elm, h('div#attached', 'First text')),
      ]),
    ]);
    var vnode2 = h('div', [
      h('div#wrapper', [
        h('div', 'Some element'),
        attachTo(elm, h('div#attached', 'New text')),
      ]),
    ]);
    patch(vnode0, vnode1);
    assert.equal(elm.children[0].innerHTML, 'First text');
    patch(vnode1, vnode2);
    assert.equal(elm.children[0].innerHTML, 'New text');
  });
  it('element can be inserted before modal', function() {
    var vnode1 = h('div', [
      h('div#wrapper', [
        h('div', 'Some element'),
        attachTo(elm, h('div#attached', 'Text')),
      ]),
    ]);
    var vnode2 = h('div', [
      h('div#wrapper', [
        h('div', 'Some element'),
        h('div', 'A new element'),
        attachTo(elm, h('div#attached', 'Text')),
      ]),
    ]);
    patch(vnode0, vnode1);
    assert.equal(elm.children[0].innerHTML, 'Text');
    patch(vnode1, vnode2);
    assert.equal(elm.children[0].innerHTML, 'Text');
  });
  it('removes element at target', function() {
    var vnode1 = h('div', [
      h('div#wrapper', [
        h('div', 'Some element'),
        attachTo(elm, h('div#attached', 'First text')),
      ]),
    ]);
    var vnode2 = h('div', [
      h('div#wrapper', [
        h('div', 'Some element'),
      ]),
    ]);
    patch(vnode0, vnode1);
    assert.equal(elm.children[0].innerHTML, 'First text');
    patch(vnode1, vnode2);
    assert.equal(elm.children.length, 1);
  });
});

},{"../h":1,"../helpers/attachto":2,"../snabbdom":10,"assert":18}],12:[function(require,module,exports){
var assert = require('assert');
var shuffle = require('knuth-shuffle').knuthShuffle;

var snabbdom = require('../snabbdom');
var patch = snabbdom.init([
  require('../modules/class'),
  require('../modules/props'),
  require('../modules/eventlisteners'),
]);
var h = require('../h');

function prop(name) {
  return function(obj) {
    return obj[name];
  };
}

function map(fn, list) {
  var ret = [];
  for (var i = 0; i < list.length; ++i) {
    ret[i] = fn(list[i]);
  }
  return ret;
}

var inner = prop('innerHTML');

describe('snabbdom', function() {
  var elm, vnode0;
  beforeEach(function() {
    elm = document.createElement('div');
    vnode0 = elm;
  });
  describe('hyperscript', function() {
    it('can create vnode with proper tag', function() {
      assert.equal(h('div').sel, 'div');
      assert.equal(h('a').sel, 'a');
    });
    it('can create vnode with children', function() {
      var vnode = h('div', [h('span#hello'), h('b.world')]);
      assert.equal(vnode.sel, 'div');
      assert.equal(vnode.children[0].sel, 'span#hello');
      assert.equal(vnode.children[1].sel, 'b.world');
    });
    it('can create vnode with text content', function() {
      var vnode = h('a', ['I am a string']);
      assert.equal(vnode.children[0].text, 'I am a string');
    });
    it('can create vnode with text content in string', function() {
      var vnode = h('a', 'I am a string');
      assert.equal(vnode.text, 'I am a string');
    });
    it('can create vnode with props and text content in string', function() {
      var vnode = h('a', {}, 'I am a string');
      assert.equal(vnode.text, 'I am a string');
    });
  });
  describe('created element', function() {
    it('has tag', function() {
      patch(vnode0, h('div'));
      assert.equal(elm.tagName, 'DIV');
    });
    it('has id', function() {
      patch(vnode0, h('div', [h('div#unique')]));
      assert.equal(elm.firstChild.id, 'unique');
    });
    it('has correct namespace', function() {
      patch(vnode0, h('div', [h('div', {ns: 'http://www.w3.org/2000/svg'})]));
      assert.equal(elm.firstChild.namespaceURI, 'http://www.w3.org/2000/svg');
    });
    it('is recieves classes in selector', function() {
      patch(vnode0, h('div', [h('i.am.a.class')]));
      assert(elm.firstChild.classList.contains('am'));
      assert(elm.firstChild.classList.contains('a'));
      assert(elm.firstChild.classList.contains('class'));
    });
    it('is recieves classes in class property', function() {
      patch(vnode0, h('i', {class: {am: true, a: true, class: true, not: false}}));
      assert(elm.classList.contains('am'));
      assert(elm.classList.contains('a'));
      assert(elm.classList.contains('class'));
      assert(!elm.classList.contains('not'));
    });
    it('handles classes from both selector and property', function() {
      patch(vnode0, h('div', [h('i.has', {class: {classes: true}})]));
      assert(elm.firstChild.classList.contains('has'));
      assert(elm.firstChild.classList.contains('classes'));
    });
    it('can create elements with text content', function() {
      patch(vnode0, h('div', ['I am a string']));
      assert.equal(elm.innerHTML, 'I am a string');
    });
    it('can create elements with span and text content', function() {
      patch(vnode0, h('a', [h('span'), 'I am a string']));
      assert.equal(elm.childNodes[0].tagName, 'SPAN');
      assert.equal(elm.childNodes[1].textContent, 'I am a string');
    });
  });
  describe('pathing an element', function() {
    it('changes the elements classes', function() {
      var vnode1 = h('i', {class: {i: true, am: true, horse: true}});
      var vnode2 = h('i', {class: {i: true, am: true, horse: false}});
      patch(vnode0, vnode1);
      patch(vnode1, vnode2);
      assert(elm.classList.contains('i'));
      assert(elm.classList.contains('am'));
      assert(!elm.classList.contains('horse'));
    });
    it('changes classes in selector', function() {
      var vnode1 = h('i', {class: {i: true, am: true, horse: true}});
      var vnode2 = h('i', {class: {i: true, am: true, horse: false}});
      patch(vnode0, vnode1);
      patch(vnode1, vnode2);
      assert(elm.classList.contains('i'));
      assert(elm.classList.contains('am'));
      assert(!elm.classList.contains('horse'));
    });
    describe('updating children with keys', function() {
      function spanNum(n) {
        if (typeof n === 'string') {
          return h('span', {}, n);
        } else {
          return h('span', {key: n}, n.toString());
        }
      }
      describe('addition of elements', function() {
        it('appends elements', function() {
          var vnode1 = h('span', [1].map(spanNum));
          var vnode2 = h('span', [1, 2, 3].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 1);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 3);
          assert.equal(elm.children[1].innerHTML, '2');
          assert.equal(elm.children[2].innerHTML, '3');
        });
        it('prepends elements', function() {
          var vnode1 = h('span', [4, 5].map(spanNum));
          var vnode2 = h('span', [1, 2, 3, 4, 5].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 2);
          patch(vnode1, vnode2);
          assert.deepEqual(map(inner, elm.children), ['1', '2', '3', '4', '5']);
        });
        it('add elements in the middle', function() {
          var vnode1 = h('span', [1, 2, 4, 5].map(spanNum));
          var vnode2 = h('span', [1, 2, 3, 4, 5].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 4);
          assert.equal(elm.children.length, 4);
          patch(vnode1, vnode2);
          assert.deepEqual(map(inner, elm.children), ['1', '2', '3', '4', '5']);
        });
        it('add elements at begin and end', function() {
          var vnode1 = h('span', [2, 3, 4].map(spanNum));
          var vnode2 = h('span', [1, 2, 3, 4, 5].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 3);
          patch(vnode1, vnode2);
          assert.deepEqual(map(inner, elm.children), ['1', '2', '3', '4', '5']);
        });
        it('adds children to parent with no children', function() {
          var vnode1 = h('span', {key: 'span'});
          var vnode2 = h('span', {key: 'span'}, [1, 2, 3].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 0);
          patch(vnode1, vnode2);
          assert.deepEqual(map(inner, elm.children), ['1', '2', '3']);
        });
        it('removes all children from parent', function() {
          var vnode1 = h('span', {key: 'span'}, [1, 2, 3].map(spanNum));
          var vnode2 = h('span', {key: 'span'});
          patch(vnode0, vnode1);
          assert.deepEqual(map(inner, elm.children), ['1', '2', '3']);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 0);
        });
      });
      describe('removal of elements', function() {
        it('removes elements from the beginning', function() {
          var vnode1 = h('span', [1, 2, 3, 4, 5].map(spanNum));
          var vnode2 = h('span', [3, 4, 5].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 5);
          patch(vnode1, vnode2);
          assert.deepEqual(map(inner, elm.children), ['3', '4', '5']);
        });
        it('removes elements from the end', function() {
          var vnode1 = h('span', [1, 2, 3, 4, 5].map(spanNum));
          var vnode2 = h('span', [1, 2, 3].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 5);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 3);
          assert.equal(elm.children[0].innerHTML, '1');
          assert.equal(elm.children[1].innerHTML, '2');
          assert.equal(elm.children[2].innerHTML, '3');
        });
        it('removes elements from the middle', function() {
          var vnode1 = h('span', [1, 2, 3, 4, 5].map(spanNum));
          var vnode2 = h('span', [1, 2, 4, 5].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 5);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 4);
          assert.deepEqual(elm.children[0].innerHTML, '1');
          assert.equal(elm.children[0].innerHTML, '1');
          assert.equal(elm.children[1].innerHTML, '2');
          assert.equal(elm.children[2].innerHTML, '4');
          assert.equal(elm.children[3].innerHTML, '5');
        });
      });
      describe('element reordering', function() {
        it('moves element forward', function() {
          var vnode1 = h('span', [1, 2, 3, 4].map(spanNum));
          var vnode2 = h('span', [2, 3, 1, 4].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 4);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 4);
          assert.equal(elm.children[0].innerHTML, '2');
          assert.equal(elm.children[1].innerHTML, '3');
          assert.equal(elm.children[2].innerHTML, '1');
          assert.equal(elm.children[3].innerHTML, '4');
        });
        it('moves element to end', function() {
          var vnode1 = h('span', [1, 2, 3].map(spanNum));
          var vnode2 = h('span', [2, 3, 1].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 3);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 3);
          assert.equal(elm.children[0].innerHTML, '2');
          assert.equal(elm.children[1].innerHTML, '3');
          assert.equal(elm.children[2].innerHTML, '1');
        });
        it('moves element backwards', function() {
          var vnode1 = h('span', [1, 2, 3, 4].map(spanNum));
          var vnode2 = h('span', [1, 4, 2, 3].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 4);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 4);
          assert.equal(elm.children[0].innerHTML, '1');
          assert.equal(elm.children[1].innerHTML, '4');
          assert.equal(elm.children[2].innerHTML, '2');
          assert.equal(elm.children[3].innerHTML, '3');
        });
        it('swaps first and last', function() {
          var vnode1 = h('span', [1, 2, 3, 4].map(spanNum));
          var vnode2 = h('span', [4, 2, 3, 1].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 4);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 4);
          assert.equal(elm.children[0].innerHTML, '4');
          assert.equal(elm.children[1].innerHTML, '2');
          assert.equal(elm.children[2].innerHTML, '3');
          assert.equal(elm.children[3].innerHTML, '1');
        });
      });
      describe('combinations of additions, removals and reorderings', function() {
        it('move to left and replace', function() {
          var vnode1 = h('span', [1, 2, 3, 4, 5].map(spanNum));
          var vnode2 = h('span', [4, 1, 2, 3, 6].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 5);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 5);
          assert.equal(elm.children[0].innerHTML, '4');
          assert.equal(elm.children[1].innerHTML, '1');
          assert.equal(elm.children[2].innerHTML, '2');
          assert.equal(elm.children[3].innerHTML, '3');
          assert.equal(elm.children[4].innerHTML, '6');
        });
        it('moves to left and leaves hole', function() {
          var vnode1 = h('span', [1, 4, 5].map(spanNum));
          var vnode2 = h('span', [4, 6].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 3);
          patch(vnode1, vnode2);
          assert.deepEqual(map(inner, elm.children), ['4', '6']);
        });
        it('handles moved and set to undefined element ending at the end', function() {
          var vnode1 = h('span', [2, 4, 5].map(spanNum));
          var vnode2 = h('span', [4, 5, 3].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.children.length, 3);
          patch(vnode1, vnode2);
          assert.equal(elm.children.length, 3);
          assert.equal(elm.children[0].innerHTML, '4');
          assert.equal(elm.children[1].innerHTML, '5');
          assert.equal(elm.children[2].innerHTML, '3');
        });
        it('moves a key in non-keyed nodes with a size up', function() {
          var vnode1 = h('span', [1, 'a', 'b', 'c'].map(spanNum));
          var vnode2 = h('span', ['d', 'a', 'b', 'c', 1, 'e'].map(spanNum));
          patch(vnode0, vnode1);
          assert.equal(elm.childNodes.length, 4);
          assert.equal(elm.textContent, '1abc');
          patch(vnode1, vnode2);
          assert.equal(elm.childNodes.length, 6);
          assert.equal(elm.textContent, 'dabc1e');
        });
      });
      it('reverses elements', function() {
        var vnode1 = h('span', [1, 2, 3, 4, 5, 6, 7, 8].map(spanNum));
        var vnode2 = h('span', [8, 7, 6, 5, 4, 3, 2, 1].map(spanNum));
        patch(vnode0, vnode1);
        assert.equal(elm.children.length, 8);
        patch(vnode1, vnode2);
        assert.deepEqual(map(inner, elm.children), ['8', '7', '6', '5', '4', '3', '2', '1']);
      });
      it('something', function() {
        var vnode1 = h('span', [0, 1, 2, 3, 4, 5].map(spanNum));
        var vnode2 = h('span', [4, 3, 2, 1, 5, 0].map(spanNum));
        patch(vnode0, vnode1);
        assert.equal(elm.children.length, 6);
        patch(vnode1, vnode2);
        assert.deepEqual(map(inner, elm.children), ['4', '3', '2', '1', '5', '0']);
      });
      it('handles random shuffles', function() {
        var n, i, arr = [], opacities = [], elms = 14, samples = 5;
        function spanNumWithOpacity(n, o) {
          return h('span', {key: n, style: {opacity: o}}, n.toString());
        }
        for (n = 0; n < elms; ++n) { arr[n] = n; }
        for (n = 0; n < samples; ++n) {
          var vnode1 = h('span', arr.map(function(n) {
            return spanNumWithOpacity(n, '1');
          }));
          var shufArr = shuffle(arr.slice(0));
          var elm = document.createElement('div');
          patch(elm, vnode1);
          for (i = 0; i < elms; ++i) {
            assert.equal(elm.children[i].innerHTML, i.toString());
            opacities[i] = Math.random().toFixed(5).toString();
          }
          var vnode2 = h('span', arr.map(function(n) {
            return spanNumWithOpacity(shufArr[n], opacities[n]);
          }));
          patch(vnode1, vnode2);
          for (i = 0; i < elms; ++i) {
            assert.equal(elm.children[i].innerHTML, shufArr[i].toString());
            assert.equal(opacities[i].indexOf(elm.children[i].style.opacity), 0);
          }
        }
      });
    });
    describe('updating children without keys', function() {
      it('appends elements', function() {
        var vnode1 = h('div', [h('span', 'Hello')]);
        var vnode2 = h('div', [h('span', 'Hello'), h('span', 'World')]);
        patch(vnode0, vnode1);
        assert.deepEqual(map(inner, elm.children), ['Hello']);
        patch(vnode1, vnode2);
        assert.deepEqual(map(inner, elm.children), ['Hello', 'World']);
      });
      it('handles unmoved text nodes', function() {
        var vnode1 = h('div', ['Text', h('span', 'Span')]);
        var vnode2 = h('div', ['Text', h('span', 'Span')]);
        patch(vnode0, vnode1);
        assert.equal(elm.childNodes[0].textContent, 'Text');
        patch(vnode1, vnode2);
        assert.equal(elm.childNodes[0].textContent, 'Text');
      });
      it('handles changing text children', function() {
        var vnode1 = h('div', ['Text', h('span', 'Span')]);
        var vnode2 = h('div', ['Text2', h('span', 'Span')]);
        patch(vnode0, vnode1);
        assert.equal(elm.childNodes[0].textContent, 'Text');
        patch(vnode1, vnode2);
        assert.equal(elm.childNodes[0].textContent, 'Text2');
      });
      it('prepends element', function() {
        var vnode1 = h('div', [h('span', 'World')]);
        var vnode2 = h('div', [h('span', 'Hello'), h('span', 'World')]);
        patch(vnode0, vnode1);
        assert.deepEqual(map(inner, elm.children), ['World']);
        patch(vnode1, vnode2);
        assert.deepEqual(map(inner, elm.children), ['Hello', 'World']);
      });
      it('prepends element of different tag type', function() {
        var vnode1 = h('div', [h('span', 'World')]);
        var vnode2 = h('div', [h('div', 'Hello'), h('span', 'World')]);
        patch(vnode0, vnode1);
        assert.deepEqual(map(inner, elm.children), ['World']);
        patch(vnode1, vnode2);
        assert.deepEqual(map(prop('tagName'), elm.children), ['DIV', 'SPAN']);
        assert.deepEqual(map(inner, elm.children), ['Hello', 'World']);
      });
      it('removes elements', function() {
        var vnode1 = h('div', [h('span', 'One'), h('span', 'Two'), h('span', 'Three')]);
        var vnode2 = h('div', [h('span', 'One'), h('span', 'Three')]);
        patch(vnode0, vnode1);
        assert.deepEqual(map(inner, elm.children), ['One', 'Two', 'Three']);
        patch(vnode1, vnode2);
        assert.deepEqual(map(inner, elm.children), ['One', 'Three']);
      });
      it('reorders elements', function() {
        var vnode1 = h('div', [h('span', 'One'), h('div', 'Two'), h('b', 'Three')]);
        var vnode2 = h('div', [h('b', 'Three'), h('span', 'One'), h('div', 'Two')]);
        patch(vnode0, vnode1);
        assert.deepEqual(map(inner, elm.children), ['One', 'Two', 'Three']);
        patch(vnode1, vnode2);
        assert.deepEqual(map(prop('tagName'), elm.children), ['B', 'SPAN', 'DIV']);
        assert.deepEqual(map(inner, elm.children), ['Three', 'One', 'Two']);
      });
    });
  });
  describe('event handling', function() {
    it('attaches click event handler to element', function() {
      var result = [];
      function clicked(ev) { result.push(ev); }
      var vnode = h('div', {on: {click: clicked}}, [
        h('a', 'Click my parent'),
      ]);
      patch(vnode0, vnode);
      elm.click();
      assert.equal(1, result.length);
    });
    it('does not attach new listener', function() {
      var result = [];
      //function clicked(ev) { result.push(ev); }
      var vnode1 = h('div', {on: {click: function(ev) { result.push(1); }}}, [
        h('a', 'Click my parent'),
      ]);
      var vnode2 = h('div', {on: {click: function(ev) { result.push(2); }}}, [
        h('a', 'Click my parent'),
      ]);
      patch(vnode0, vnode1);
      elm.click();
      patch(vnode1, vnode2);
      elm.click();
      assert.deepEqual(result, [1, 2]);
    });
    it('does calls handler for function in array', function() {
      var result = [];
      function clicked(ev) { result.push(ev); }
      var vnode = h('div', {on: {click: [clicked, 1]}}, [
        h('a', 'Click my parent'),
      ]);
      patch(vnode0, vnode);
      elm.click();
      assert.deepEqual(result, [1]);
    });
    it('handles changed value in array', function() {
      var result = [];
      function clicked(ev) { result.push(ev); }
      var vnode1 = h('div', {on: {click: [clicked, 1]}}, [
        h('a', 'Click my parent'),
      ]);
      var vnode2 = h('div', {on: {click: [clicked, 2]}}, [
        h('a', 'Click my parent'),
      ]);
      var vnode3 = h('div', {on: {click: [clicked, 3]}}, [
        h('a', 'Click my parent'),
      ]);
      patch(vnode0, vnode1);
      elm.click();
      patch(vnode1, vnode2);
      elm.click();
      patch(vnode2, vnode3);
      elm.click();
      assert.deepEqual(result, [1, 2, 3]);
    });
  });
  describe('hooks', function() {
    describe('element hooks', function() {
      it('calls `create` listener before inserted into parent but after children', function() {
        var result = [];
        function cb(empty, vnode) {
          assert(vnode.elm instanceof Element);
          assert.equal(vnode.elm.children.length, 2);
          assert.strictEqual(vnode.elm.parentNode, null);
          result.push(vnode);
        }
        var vnode1 = h('div', [
          h('span', 'First sibling'),
          h('div', {hook: {create: cb}}, [
            h('span', 'Child 1'),
            h('span', 'Child 2'),
          ]),
          h('span', 'Can\'t touch me'),
        ]);
        patch(vnode0, vnode1);
        assert.equal(1, result.length);
      });
      it('calls `insert` listener after both parents, siblings and children have been inserted', function() {
        var result = [];
        function cb(vnode) {
          assert(vnode.elm instanceof Element);
          assert.equal(vnode.elm.children.length, 2);
          assert.equal(vnode.elm.parentNode.children.length, 3);
          result.push(vnode);
        }
        var vnode1 = h('div', [
          h('span', 'First sibling'),
          h('div', {hook: {insert: cb}}, [
            h('span', 'Child 1'),
            h('span', 'Child 2'),
          ]),
          h('span', 'Can touch me'),
        ]);
        patch(vnode0, vnode1);
        assert.equal(1, result.length);
      });
      it('calls `prepatch` listener', function() {
        var result = [];
        function cb(oldVnode, vnode) {
          assert.strictEqual(oldVnode, vnode1.children[1]);
          assert.strictEqual(vnode, vnode2.children[1]);
          result.push(vnode);
        }
        var vnode1 = h('div', [
          h('span', 'First sibling'),
          h('div', {hook: {prepatch: cb}}, [
            h('span', 'Child 1'),
            h('span', 'Child 2'),
          ]),
        ]);
        var vnode2 = h('div', [
          h('span', 'First sibling'),
          h('div', {hook: {prepatch: cb}}, [
            h('span', 'Child 1'),
            h('span', 'Child 2'),
          ]),
        ]);
        patch(vnode0, vnode1);
        patch(vnode1, vnode2);
        assert.equal(result.length, 1);
      });
      it('calls `postpatch` after `prepatch` listener', function() {
        var pre = [], post = [];
        function preCb(oldVnode, vnode) {
          pre.push(pre);
        }
        function postCb(oldVnode, vnode) {
          assert.equal(pre.length, post.length + 1);
          post.push(post);
        }
        var vnode1 = h('div', [
          h('span', 'First sibling'),
          h('div', {hook: {prepatch: preCb, postpatch: postCb}}, [
            h('span', 'Child 1'),
            h('span', 'Child 2'),
          ]),
        ]);
        var vnode2 = h('div', [
          h('span', 'First sibling'),
          h('div', {hook: {prepatch: preCb, postpatch: postCb}}, [
            h('span', 'Child 1'),
            h('span', 'Child 2'),
          ]),
        ]);
        patch(vnode0, vnode1);
        patch(vnode1, vnode2);
        assert.equal(pre.length, 1);
        assert.equal(post.length, 1);
      });
      it('calls `update` listener', function() {
        var result1 = [];
        var result2 = [];
        function cb(result, oldVnode, vnode) {
          if (result.length > 0) {
            console.log(result[result.length-1]);
            console.log(oldVnode);
            assert.strictEqual(result[result.length-1], oldVnode);
          }
          result.push(vnode);
        }
        var vnode1 = h('div', [
          h('span', 'First sibling'),
          h('div', {hook: {update: cb.bind(null, result1)}}, [
            h('span', 'Child 1'),
            h('span', {hook: {update: cb.bind(null, result2)}}, 'Child 2'),
          ]),
        ]);
        var vnode2 = h('div', [
          h('span', 'First sibling'),
          h('div', {hook: {update: cb.bind(null, result1)}}, [
            h('span', 'Child 1'),
            h('span', {hook: {update: cb.bind(null, result2)}}, 'Child 2'),
          ]),
        ]);
        patch(vnode0, vnode1);
        patch(vnode1, vnode2);
        assert.equal(result1.length, 1);
        assert.equal(result2.length, 1);
      });
      it('calls `remove` listener', function() {
        var result = [];
        function cb(vnode, rm) {
          var parent = vnode.elm.parentNode;
          assert(vnode.elm instanceof Element);
          assert.equal(vnode.elm.children.length, 2);
          assert.equal(parent.children.length, 2);
          result.push(vnode);
          rm();
          assert.equal(parent.children.length, 1);
        }
        var vnode1 = h('div', [
          h('span', 'First sibling'),
          h('div', {hook: {remove: cb}}, [
            h('span', 'Child 1'),
            h('span', 'Child 2'),
          ]),
        ]);
        var vnode2 = h('div', [
          h('span', 'First sibling'),
        ]);
        patch(vnode0, vnode1);
        patch(vnode1, vnode2);
        assert.equal(1, result.length);
      });
      it('removes element when all remove listeners are done', function() {
        var rm1, rm2, rm3;
        var patch = snabbdom.init([
          {remove: function(_, rm) { rm1 = rm; }},
          {remove: function(_, rm) { rm2 = rm; }},
        ]);
        var vnode1 = h('div', [h('a', {hook: {remove: function(_, rm) { rm3 = rm; }}})]);
        patch(vnode0, vnode1);
        assert.equal(elm.children.length, 1);
        patch(vnode1, vnode0);
        assert.equal(elm.children.length, 1);
        rm1();
        assert.equal(elm.children.length, 1);
        rm3();
        assert.equal(elm.children.length, 1);
        rm2();
        assert.equal(elm.children.length, 0);
      });
    });
    describe('module hooks', function() {
      it('invokes `pre` and `post` hook', function() {
        var result = [];
        var patch = snabbdom.init([
          {pre: function() { result.push('pre'); }},
          {post: function() { result.push('post'); }},
        ]);
        var vnode1 = h('div');
        patch(vnode0, vnode1);
        assert.deepEqual(result, ['pre', 'post']);
      });
      it('invokes global `destroy` hook for all removed children', function() {
        var result = [];
        function cb(vnode) { result.push(vnode); }
        var vnode1 = h('div', [
          h('span', 'First sibling'),
          h('div', [
            h('span', {hook: {destroy: cb}}, 'Child 1'),
            h('span', 'Child 2'),
          ]),
        ]);
        patch(vnode0, vnode1);
        patch(vnode1, vnode0);
        assert.equal(result.length, 1);
      });
      it('handles text vnodes with `undefined` `data` property', function() {
        var vnode1 = h('div', [
          ' '
        ]);
        var vnode2 = h('div', []);
        patch(vnode0, vnode1);
        patch(vnode1, vnode2);
      });
      it('invokes `destroy` module hook for all removed children', function() {
        var created = 0;
        var destroyed = 0;
        var patch = snabbdom.init([
          {create: function() { created++; }},
          {destroy: function() { destroyed++; }},
        ]);
        var vnode1 = h('div', [
          h('span', 'First sibling'),
          h('div', [
            h('span', 'Child 1'),
            h('span', 'Child 2'),
          ]),
        ]);
        patch(vnode0, vnode1);
        patch(vnode1, vnode0);
        assert.equal(created, 4);
        assert.equal(destroyed, 4);
      });
      it('does not invoke `destroy` module hook for text nodes', function() {
        var created = 0;
        var destroyed = 0;
        var patch = snabbdom.init([
          {create: function() { created++; }},
          {destroy: function() { destroyed++; }},
        ]);
        var vnode1 = h('div', [
          h('span', 'First sibling'),
          h('div', [
            h('span', 'Child 1'),
            h('span', ['Text 1', 'Text 2']),
          ]),
        ]);
        patch(vnode0, vnode1);
        patch(vnode1, vnode0);
        assert.equal(created, 4);
        assert.equal(destroyed, 4);
      });
    });
  });
  describe('short circuiting', function() {
    it('does not update strictly equal vnodes', function() {
      var result = [];
      function cb(vnode) { result.push(vnode); }
      var vnode1 = h('div', [
        h('span', {hook: {update: cb}}, 'Hello'),
        h('span', 'there'),
      ]);
      patch(vnode0, vnode1);
      patch(vnode1, vnode1);
      assert.equal(result.length, 0);
    });
    it('does not update strictly equal children', function() {
      var result = [];
      function cb(vnode) { result.push(vnode); }
      var vnode1 = h('div', [
        h('span', {hook: {patch: cb}}, 'Hello'),
        h('span', 'there'),
      ]);
      var vnode2 = h('div');
      vnode2.children = vnode1.children;
      patch(vnode0, vnode1);
      patch(vnode1, vnode2);
      assert.equal(result.length, 0);
    });
  });
});

},{"../h":1,"../modules/class":4,"../modules/eventlisteners":5,"../modules/props":6,"../snabbdom":10,"assert":18,"knuth-shuffle":9}],13:[function(require,module,exports){
require('./core');
require('./style');
require('./attachto');
require('./thunk');

},{"./attachto":11,"./core":12,"./style":14,"./thunk":15}],14:[function(require,module,exports){
var assert = require('assert');
var fakeRaf = require('fake-raf');

var snabbdom = require('../snabbdom');
fakeRaf.use();
var patch = snabbdom.init([
  require('../modules/style'),
]);
var h = require('../h');

describe('style', function() {
  var elm, vnode0;
  beforeEach(function() {
    elm = document.createElement('div');
    vnode0 = elm;
  });
  it('is being styled', function() {
    patch(vnode0, h('div', {style: {fontSize: '12px'}}));
    assert.equal(elm.style.fontSize, '12px');
  });
  it('updates styles', function() {
    var vnode1 = h('i', {style: {fontSize: '14px', display: 'inline'}});
    var vnode2 = h('i', {style: {fontSize: '12px', display: 'block'}});
    var vnode3 = h('i', {style: {fontSize: '10px', display: 'block'}});
    patch(vnode0, vnode1);
    assert.equal(elm.style.fontSize, '14px');
    assert.equal(elm.style.display, 'inline');
    patch(vnode1, vnode2);
    assert.equal(elm.style.fontSize, '12px');
    assert.equal(elm.style.display, 'block');
    patch(vnode2, vnode3);
    assert.equal(elm.style.fontSize, '10px');
    assert.equal(elm.style.display, 'block');
  });
  it('updates delayed styles in next frame', function() {
    var patch = snabbdom.init([
      require('../modules/style'),
    ]);
    var vnode1 = h('i', {style: {fontSize: '14px', delayed: {fontSize: '16px'}}});
    var vnode2 = h('i', {style: {fontSize: '18px', delayed: {fontSize: '20px'}}});
    patch(vnode0, vnode1);
    assert.equal(elm.style.fontSize, '14px');
    fakeRaf.step();
    fakeRaf.step();
    assert.equal(elm.style.fontSize, '16px');
    patch(vnode1, vnode2);
    assert.equal(elm.style.fontSize, '18px');
    fakeRaf.step();
    fakeRaf.step();
    assert.equal(elm.style.fontSize, '20px');
  });
});

fakeRaf.restore();

},{"../h":1,"../modules/style":7,"../snabbdom":10,"assert":18,"fake-raf":8}],15:[function(require,module,exports){
var assert = require('assert');

var snabbdom = require('../snabbdom');
var patch = snabbdom.init([
]);
var h = require('../h');
var thunk = require('../thunk');

describe('thunk', function() {
  var elm, vnode0;
  beforeEach(function() {
    elm = document.createElement('div');
    vnode0 = elm;
  });
  it('returns vnode with data and render function', function() {
    function numberInSpan(n) {
      return h('span', 'Number is ' + n);
    }
    var vnode = thunk('num', numberInSpan, 22);
    assert.deepEqual(vnode.sel, 'thunknum');
    assert.deepEqual(vnode.data.args, [22]);
  });
  it('only calls render function on data change', function() {
    var called = 0;
    function numberInSpan(n) {
      called++;
      return h('span', 'Number is ' + n);
    }
    var vnode1 = h('div', [
      thunk('num', numberInSpan, 1)
    ]);
    var vnode2 = h('div', [
      thunk('num', numberInSpan, 1)
    ]);
    var vnode3 = h('div', [
      thunk('num', numberInSpan, 2)
    ]);
    patch(vnode0, vnode1);
    patch(vnode1, vnode2);
    patch(vnode2, vnode3);
    assert.equal(called, 2);
  });
  it('renders correctly', function() {
    var called = 0;
    function numberInSpan(n) {
      called++;
      return h('span', 'Number is ' + n);
    }
    var vnode1 = h('div', [
      thunk('num', numberInSpan, 1)
    ]);
    var vnode2 = h('div', [
      thunk('num', numberInSpan, 1)
    ]);
    var vnode3 = h('div', [
      thunk('num', numberInSpan, 2)
    ]);
    patch(vnode0, vnode1);
    assert.equal(elm.firstChild.innerHTML, 'Number is 1');
    patch(vnode1, vnode2);
    assert.equal(elm.firstChild.innerHTML, 'Number is 1');
    patch(vnode2, vnode3);
    assert.equal(elm.firstChild.innerHTML, 'Number is 2');
    assert.equal(called, 2);
  });
});

},{"../h":1,"../snabbdom":10,"../thunk":16,"assert":18}],16:[function(require,module,exports){
var h = require('./h');

function init(thunk) {
  var i, cur = thunk.data;
  cur.vnode = cur.fn.apply(undefined, cur.args);
}

function prepatch(oldThunk, thunk) {
  var i, old = oldThunk.data, cur = thunk.data;
  var oldArgs = old.args, args = cur.args;
  cur.vnode = old.vnode;
  if (oldArgs.length !== args.length) {
    cur.vnode = cur.fn.apply(undefined, args);
    return;
  }
  for (i = 0; i < args.length; ++i) {
    if (oldArgs[i] !== args[i]) {
      cur.vnode = cur.fn.apply(undefined, args);
      return;
    }
  }
}

module.exports = function(name, fn /* args */) {
  var i, args = [];
  for (i = 2; i < arguments.length; ++i) {
    args[i - 2] = arguments[i];
  }
  return h('thunk' + name, {
    hook: {init: init, prepatch: prepatch},
    fn: fn, args: args,
  });
};

},{"./h":1}],17:[function(require,module,exports){
module.exports = function(sel, data, children, text, elm) {
  var key = data === undefined ? undefined : data.key;
  return {sel: sel, data: data, children: children,
          text: text, elm: elm, key: key};
};

},{}],18:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":22}],19:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],20:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],21:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],22:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":21,"_process":20,"inherits":19}]},{},[13])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImguanMiLCJoZWxwZXJzL2F0dGFjaHRvLmpzIiwiaXMuanMiLCJtb2R1bGVzL2NsYXNzLmpzIiwibW9kdWxlcy9ldmVudGxpc3RlbmVycy5qcyIsIm1vZHVsZXMvcHJvcHMuanMiLCJtb2R1bGVzL3N0eWxlLmpzIiwibm9kZV9tb2R1bGVzL2Zha2UtcmFmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2tudXRoLXNodWZmbGUvaW5kZXguanMiLCJzbmFiYmRvbS5qcyIsInRlc3QvYXR0YWNodG8uanMiLCJ0ZXN0L2NvcmUuanMiLCJ0ZXN0L2luZGV4LmpzIiwidGVzdC9zdHlsZS5qcyIsInRlc3QvdGh1bmsuanMiLCJ0aHVuay5qcyIsInZub2RlLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIuLi8uLi8uLi8uLi91c3IvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi8uLi91c3IvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwiLi4vLi4vLi4vLi4vdXNyL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgVk5vZGUgPSByZXF1aXJlKCcuL3Zub2RlJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuL2lzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaChzZWwsIGIsIGMpIHtcbiAgdmFyIGRhdGEgPSB7fSwgY2hpbGRyZW4sIHRleHQsIGk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgZGF0YSA9IGI7XG4gICAgaWYgKGlzLmFycmF5KGMpKSB7IGNoaWxkcmVuID0gYzsgfVxuICAgIGVsc2UgaWYgKGlzLnByaW1pdGl2ZShjKSkgeyB0ZXh0ID0gYzsgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAoaXMuYXJyYXkoYikpIHsgY2hpbGRyZW4gPSBiOyB9XG4gICAgZWxzZSBpZiAoaXMucHJpbWl0aXZlKGIpKSB7IHRleHQgPSBiOyB9XG4gICAgZWxzZSB7IGRhdGEgPSBiOyB9XG4gIH1cbiAgaWYgKGlzLmFycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGlzLnByaW1pdGl2ZShjaGlsZHJlbltpXSkpIGNoaWxkcmVuW2ldID0gVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gVk5vZGUoc2VsLCBkYXRhLCBjaGlsZHJlbiwgdGV4dCwgdW5kZWZpbmVkKTtcbn07XG4iLCJmdW5jdGlvbiBwcmUodm5vZGUsIG5ld1Zub2RlKSB7XG4gIHZhciBhdHRhY2hEYXRhID0gdm5vZGUuZGF0YS5hdHRhY2hEYXRhO1xuICAvLyBDb3B5IGNyZWF0ZWQgcGxhY2Vob2xkZXIgYW5kIHJlYWwgZWxlbWVudCBmcm9tIG9sZCB2bm9kZVxuICBuZXdWbm9kZS5kYXRhLmF0dGFjaERhdGEucGxhY2Vob2xkZXIgPSBhdHRhY2hEYXRhLnBsYWNlaG9sZGVyO1xuICBuZXdWbm9kZS5kYXRhLmF0dGFjaERhdGEucmVhbCA9IGF0dGFjaERhdGEucmVhbDtcbiAgLy8gTW91bnQgcmVhbCBlbGVtZW50IGluIHZub2RlIHNvIHRoZSBwYXRjaCBwcm9jZXNzIG9wZXJhdGVzIG9uIGl0XG4gIHZub2RlLmVsbSA9IHZub2RlLmRhdGEuYXR0YWNoRGF0YS5yZWFsO1xufVxuXG5mdW5jdGlvbiBwb3N0KF8sIHZub2RlKSB7XG4gIC8vIE1vdW50IGR1bW15IHBsYWNlaG9sZGVyIGluIHZub2RlIHNvIHBvdGVudGlhbCByZW9yZGVycyB1c2UgaXRcbiAgdm5vZGUuZWxtID0gdm5vZGUuZGF0YS5hdHRhY2hEYXRhLnBsYWNlaG9sZGVyO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95KHZub2RlKSB7XG4gIC8vIFJlbW92ZSByZWFsIGVsZW1lbnQgZnJvbSB3aGVyZSBpdCB3YXMgaW5zZXJ0ZWRcbiAgdmFyIGF0dGFjaERhdGEgPSB2bm9kZS5kYXRhLmF0dGFjaERhdGE7XG4gIGF0dGFjaERhdGEudGFyZ2V0LnJlbW92ZUNoaWxkKGF0dGFjaERhdGEucmVhbCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShfLCB2bm9kZSkge1xuICB2YXIgcmVhbCA9IHZub2RlLmVsbSwgYXR0YWNoRGF0YSA9IHZub2RlLmRhdGEuYXR0YWNoRGF0YTtcbiAgdmFyIHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAvLyBSZXBsYWNlIGFjdHVhbCBlbGVtZW50IHdpdGggZHVtbXkgcGxhY2Vob2xkZXJcbiAgLy8gU25hYmJkb20gd2lsbCB0aGVuIGluc2VydCBwbGFjZWhvbGRlciBpbnN0ZWFkXG4gIHZub2RlLmVsbSA9IHBsYWNlaG9sZGVyO1xuICBhdHRhY2hEYXRhLnRhcmdldC5hcHBlbmRDaGlsZChyZWFsKTtcbiAgYXR0YWNoRGF0YS5yZWFsID0gcmVhbDtcbiAgYXR0YWNoRGF0YS5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhcmdldCwgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEgPT09IHVuZGVmaW5lZCkgdm5vZGUuZGF0YSA9IHt9O1xuICBpZiAodm5vZGUuZGF0YS5ob29rID09PSB1bmRlZmluZWQpIHZub2RlLmRhdGEuaG9vayA9IHt9O1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBob29rID0gdm5vZGUuZGF0YS5ob29rO1xuICBkYXRhLmF0dGFjaERhdGEgPSB7dGFyZ2V0OiB0YXJnZXQsIHBsYWNlaG9sZGVyOiB1bmRlZmluZWQsIHJlYWw6IHVuZGVmaW5lZH07XG4gIGhvb2suY3JlYXRlID0gY3JlYXRlO1xuICBob29rLnByZXBhdGNoID0gcHJlO1xuICBob29rLnBvc3RwYXRjaCA9IHBvc3Q7XG4gIGhvb2suZGVzdHJveSA9IGRlc3Ryb3k7XG4gIHJldHVybiB2bm9kZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXk6IEFycmF5LmlzQXJyYXksXG4gIHByaW1pdGl2ZTogZnVuY3Rpb24ocykgeyByZXR1cm4gdHlwZW9mIHMgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBzID09PSAnbnVtYmVyJzsgfSxcbn07XG4iLCJmdW5jdGlvbiB1cGRhdGVDbGFzcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGN1ciwgbmFtZSwgZWxtID0gdm5vZGUuZWxtLFxuICAgICAgb2xkQ2xhc3MgPSBvbGRWbm9kZS5kYXRhLmNsYXNzIHx8IHt9LFxuICAgICAga2xhc3MgPSB2bm9kZS5kYXRhLmNsYXNzIHx8IHt9O1xuICBmb3IgKG5hbWUgaW4ga2xhc3MpIHtcbiAgICBjdXIgPSBrbGFzc1tuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRDbGFzc1tuYW1lXSkge1xuICAgICAgZWxtLmNsYXNzTGlzdFtjdXIgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVDbGFzcywgdXBkYXRlOiB1cGRhdGVDbGFzc307XG4iLCJ2YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG5mdW5jdGlvbiBhcnJJbnZva2VyKGFycikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7IGFyclswXShhcnJbMV0pOyB9O1xufVxuXG5mdW5jdGlvbiBmbkludm9rZXIoYXJyKSB7XG4gIHJldHVybiBmdW5jdGlvbihldikgeyBhcnJbMF0oZXYpOyB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFdmVudExpc3RlbmVycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge30sIG9uID0gdm5vZGUuZGF0YS5vbjtcbiAgaWYgKCFvbikgcmV0dXJuO1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBpZiAob2xkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpcy5hcnJheShjdXIpKSB7XG4gICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGFyckludm9rZXIoY3VyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXIgPSBbY3VyXTtcbiAgICAgICAgb25bbmFtZV0gPSBjdXI7XG4gICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZuSW52b2tlcihjdXIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZC5sZW5ndGggPT09IDIpIHtcbiAgICAgIG9sZFswXSA9IGN1clswXTsgLy8gRGVsaWJlcmF0ZWx5IG1vZGlmeSBvbGQgYXJyYXkgc2luY2UgaXQnc1xuICAgICAgb2xkWzFdID0gY3VyWzFdOyAvLyBjYXB0dXJlZCBpbiBjbG9zdXJlIGNyZWF0ZWQgd2l0aCBgYXJySW52b2tlcmBcbiAgICAgIG9uW25hbWVdICA9IG9sZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkWzBdID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge2NyZWF0ZTogdXBkYXRlRXZlbnRMaXN0ZW5lcnMsIHVwZGF0ZTogdXBkYXRlRXZlbnRMaXN0ZW5lcnN9O1xuIiwiZnVuY3Rpb24gdXBkYXRlUHJvcHMob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBrZXksIGN1ciwgb2xkLCBlbG0gPSB2bm9kZS5lbG0sXG4gICAgICBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEucHJvcHMgfHwge30sIHByb3BzID0gdm5vZGUuZGF0YS5wcm9wcyB8fCB7fTtcbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIG9sZCA9IG9sZFByb3BzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVQcm9wcywgdXBkYXRlOiB1cGRhdGVQcm9wc307XG4iLCJ2YXIgcmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHNldFRpbWVvdXQ7XG52YXIgbmV4dEZyYW1lID0gZnVuY3Rpb24oZm4pIHsgcmFmKGZ1bmN0aW9uKCkgeyByYWYoZm4pOyB9KTsgfTtcblxuZnVuY3Rpb24gc2V0TmV4dEZyYW1lKG9iaiwgcHJvcCwgdmFsKSB7XG4gIG5leHRGcmFtZShmdW5jdGlvbigpIHsgb2JqW3Byb3BdID0gdmFsOyB9KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBjdXIsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSxcbiAgICAgIG9sZFN0eWxlID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fSxcbiAgICAgIHN0eWxlID0gdm5vZGUuZGF0YS5zdHlsZSB8fCB7fSxcbiAgICAgIG9sZEhhc0RlbCA9ICdkZWxheWVkJyBpbiBvbGRTdHlsZTtcbiAgZm9yIChuYW1lIGluIHN0eWxlKSB7XG4gICAgY3VyID0gc3R5bGVbbmFtZV07XG4gICAgaWYgKG5hbWUgPT09ICdkZWxheWVkJykge1xuICAgICAgZm9yIChuYW1lIGluIHN0eWxlLmRlbGF5ZWQpIHtcbiAgICAgICAgY3VyID0gc3R5bGUuZGVsYXllZFtuYW1lXTtcbiAgICAgICAgaWYgKCFvbGRIYXNEZWwgfHwgY3VyICE9PSBvbGRTdHlsZS5kZWxheWVkW25hbWVdKSB7XG4gICAgICAgICAgc2V0TmV4dEZyYW1lKGVsbS5zdHlsZSwgbmFtZSwgY3VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAhPT0gJ3JlbW92ZScgJiYgY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgZWxtLnN0eWxlW25hbWVdID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseURlc3Ryb3lTdHlsZSh2bm9kZSkge1xuICB2YXIgc3R5bGUsIG5hbWUsIGVsbSA9IHZub2RlLmVsbSwgcyA9IHZub2RlLmRhdGEuc3R5bGU7XG4gIGlmICghcyB8fCAhKHN0eWxlID0gcy5kZXN0cm95KSkgcmV0dXJuO1xuICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICBlbG0uc3R5bGVbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVJlbW92ZVN0eWxlKHZub2RlLCBybSkge1xuICB2YXIgcyA9IHZub2RlLmRhdGEuc3R5bGU7XG4gIGlmICghcyB8fCAhcy5yZW1vdmUpIHtcbiAgICBybSgpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSwgZWxtID0gdm5vZGUuZWxtLCBpZHgsIGkgPSAwLCBtYXhEdXIgPSAwLFxuICAgICAgY29tcFN0eWxlLCBzdHlsZSA9IHMucmVtb3ZlLCBhbW91bnQgPSAwO1xuICB2YXIgYXBwbGllZCA9IFtdO1xuICBmb3IgKG5hbWUgaW4gc3R5bGUpIHtcbiAgICBhcHBsaWVkLnB1c2gobmFtZSk7XG4gICAgZWxtLnN0eWxlW25hbWVdID0gc3R5bGVbbmFtZV07XG4gIH1cbiAgY29tcFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbG0pO1xuICB2YXIgcHJvcHMgPSBjb21wU3R5bGVbJ3RyYW5zaXRpb24tcHJvcGVydHknXS5zcGxpdCgnLCAnKTtcbiAgZm9yICg7IGkgPCBwcm9wcy5sZW5ndGg7ICsraSkge1xuICAgIGlmKGFwcGxpZWQuaW5kZXhPZihwcm9wc1tpXSkgIT09IC0xKSBhbW91bnQrKztcbiAgfVxuICBlbG0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKGV2LnRhcmdldCA9PT0gZWxtKSAtLWFtb3VudDtcbiAgICBpZiAoYW1vdW50ID09PSAwKSBybSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7Y3JlYXRlOiB1cGRhdGVTdHlsZSwgdXBkYXRlOiB1cGRhdGVTdHlsZSwgZGVzdHJveTogYXBwbHlEZXN0cm95U3R5bGUsIHJlbW92ZTogYXBwbHlSZW1vdmVTdHlsZX07XG4iLCJjb25zb2xlLmxvZygnbG9sJyk7XG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7IC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTsgLy8gTm9kZUpTXG4gIH0gZWxzZSB7IC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gIHJvb3QuZmFrZVJhZiA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbnZhciBvcmlnaW5hbDtcblxudmFyIHJlcXVlc3RlcnMgPSBbXTtcblxuZnVuY3Rpb24gZmFrZVJhZihmbikge1xuICByZXF1ZXN0ZXJzLnB1c2goZm4pO1xufVxuXG5mdW5jdGlvbiB1c2UoKSB7XG4gIG9yaWdpbmFsID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZha2VSYWY7XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmUoKSB7XG4gIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBvcmlnaW5hbDtcbn1cblxuZnVuY3Rpb24gc3RlcCgpIHtcbiAgdmFyIGN1ciA9IHJlcXVlc3RlcnM7XG4gIHJlcXVlc3RlcnMgPSBbXTtcbiAgY3VyLmZvckVhY2goZnVuY3Rpb24oZikgeyBmKDE2KTsgfSk7XG59XG5cbnJldHVybiB7dXNlOiB1c2UsIHJlc3RvcmU6IHJlc3RvcmUsIHN0ZXA6IHN0ZXB9O1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKmpzaGludCAtVzA1NCAqL1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI0NTA5NTQvaG93LXRvLXJhbmRvbWl6ZS1zaHVmZmxlLWEtamF2YXNjcmlwdC1hcnJheVxuICBmdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gICAgdmFyIGN1cnJlbnRJbmRleCA9IGFycmF5Lmxlbmd0aFxuICAgICAgLCB0ZW1wb3JhcnlWYWx1ZVxuICAgICAgLCByYW5kb21JbmRleFxuICAgICAgO1xuXG4gICAgLy8gV2hpbGUgdGhlcmUgcmVtYWluIGVsZW1lbnRzIHRvIHNodWZmbGUuLi5cbiAgICB3aGlsZSAoMCAhPT0gY3VycmVudEluZGV4KSB7XG5cbiAgICAgIC8vIFBpY2sgYSByZW1haW5pbmcgZWxlbWVudC4uLlxuICAgICAgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xuICAgICAgY3VycmVudEluZGV4IC09IDE7XG5cbiAgICAgIC8vIEFuZCBzd2FwIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgIHRlbXBvcmFyeVZhbHVlID0gYXJyYXlbY3VycmVudEluZGV4XTtcbiAgICAgIGFycmF5W2N1cnJlbnRJbmRleF0gPSBhcnJheVtyYW5kb21JbmRleF07XG4gICAgICBhcnJheVtyYW5kb21JbmRleF0gPSB0ZW1wb3JhcnlWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICBleHBvcnRzLmtudXRoU2h1ZmZsZSA9IHNodWZmbGU7XG59KCd1bmRlZmluZWQnICE9PSB0eXBlb2YgZXhwb3J0cyAmJiBleHBvcnRzIHx8ICd1bmRlZmluZWQnICE9PSB0eXBlb2Ygd2luZG93ICYmIHdpbmRvdyB8fCBnbG9iYWwpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiLy8ganNoaW50IG5ld2NhcDogZmFsc2Vcbi8qIGdsb2JhbCByZXF1aXJlLCBtb2R1bGUsIGRvY3VtZW50LCBFbGVtZW50ICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWTm9kZSA9IHJlcXVpcmUoJy4vdm5vZGUnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxuZnVuY3Rpb24gaXNVbmRlZihzKSB7IHJldHVybiBzID09PSB1bmRlZmluZWQ7IH1cblxuZnVuY3Rpb24gZW1wdHlOb2RlQXQoZWxtKSB7XG4gIHJldHVybiBWTm9kZShlbG0udGFnTmFtZSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSk7XG59XG5cbnZhciBlbXB0eU5vZGUgPSBWTm9kZSgnJywge30sIFtdLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG5cbnZhciBpbnNlcnRlZFZub2RlUXVldWU7XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSh2bm9kZTEsIHZub2RlMikge1xuICByZXR1cm4gdm5vZGUxLmtleSA9PT0gdm5vZGUyLmtleSAmJiB2bm9kZTEuc2VsID09PSB2bm9kZTIuc2VsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwgbWFwID0ge30sIGtleTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKCFpc1VuZGVmKGtleSkpIG1hcFtrZXldID0gaTtcbiAgfVxuICByZXR1cm4gbWFwO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSbUNiKHBhcmVudEVsbSwgY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKC0tbGlzdGVuZXJzID09PSAwKSBwYXJlbnRFbG0ucmVtb3ZlQ2hpbGQoY2hpbGRFbG0pO1xuICB9O1xufVxuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knLCAncHJlJywgJ3Bvc3QnXTtcblxuZnVuY3Rpb24gaW5pdChtb2R1bGVzKSB7XG4gIHZhciBpLCBqLCBjYnMgPSB7fTtcbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAobW9kdWxlc1tqXVtob29rc1tpXV0gIT09IHVuZGVmaW5lZCkgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbG0odm5vZGUpIHtcbiAgICB2YXIgaSwgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKCFpc1VuZGVmKGRhdGEpKSB7XG4gICAgICBpZiAoIWlzVW5kZWYoaSA9IGRhdGEuaG9vaykgJiYgIWlzVW5kZWYoaSA9IGkuaW5pdCkpIGkodm5vZGUpO1xuICAgICAgaWYgKCFpc1VuZGVmKGkgPSBkYXRhLnZub2RlKSkgdm5vZGUgPSBpO1xuICAgIH1cbiAgICB2YXIgZWxtLCBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuLCBzZWwgPSB2bm9kZS5zZWw7XG4gICAgaWYgKCFpc1VuZGVmKHNlbCkpIHtcbiAgICAgIC8vIFBhcnNlIHNlbGVjdG9yXG4gICAgICB2YXIgaGFzaElkeCA9IHNlbC5pbmRleE9mKCcjJyk7XG4gICAgICB2YXIgZG90SWR4ID0gc2VsLmluZGV4T2YoJy4nLCBoYXNoSWR4KTtcbiAgICAgIHZhciBoYXNoID0gaGFzaElkeCA+IDAgPyBoYXNoSWR4IDogc2VsLmxlbmd0aDtcbiAgICAgIHZhciBkb3QgPSBkb3RJZHggPiAwID8gZG90SWR4IDogc2VsLmxlbmd0aDtcbiAgICAgIHZhciB0YWcgPSBoYXNoSWR4ICE9PSAtMSB8fCBkb3RJZHggIT09IC0xID8gc2VsLnNsaWNlKDAsIE1hdGgubWluKGhhc2gsIGRvdCkpIDogc2VsO1xuICAgICAgZWxtID0gdm5vZGUuZWxtID0gIWlzVW5kZWYoZGF0YSkgJiYgIWlzVW5kZWYoaSA9IGRhdGEubnMpID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGksIHRhZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgIGlmIChoYXNoIDwgZG90KSBlbG0uaWQgPSBzZWwuc2xpY2UoaGFzaCArIDEsIGRvdCk7XG4gICAgICBpZiAoZG90SWR4ID4gMCkgZWxtLmNsYXNzTmFtZSA9IHNlbC5zbGljZShkb3QrMSkucmVwbGFjZSgvXFwuL2csICcgJyk7XG4gICAgICBpZiAoaXMuYXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGVsbS5hcHBlbmRDaGlsZChjcmVhdGVFbG0oY2hpbGRyZW5baV0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpcy5wcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSBjYnMuY3JlYXRlW2ldKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICAgIGlmICghaXNVbmRlZihpKSkge1xuICAgICAgICBpZiAoaS5jcmVhdGUpIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgICBpZiAoaS5pbnNlcnQpIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxtID0gdm5vZGUuZWxtID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZS5lbG07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUoY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0pLCBiZWZvcmUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rKHZub2RlKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhLCBqO1xuICAgIGlmICghaXNVbmRlZihpKSkge1xuICAgICAgaWYgKCFpc1VuZGVmKGkgPSBpLmhvb2spICYmICFpc1VuZGVmKGkgPSBpLmRlc3Ryb3kpKSBpKHZub2RlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgY2JzLmRlc3Ryb3lbaV0odm5vZGUpO1xuICAgICAgaWYgKCFpc1VuZGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgdmFyIGksIGxpc3RlbmVycywgcm0sIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcbiAgICAgIGlmICghaXNVbmRlZihjaCkpIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICAgIHJtID0gY3JlYXRlUm1DYihwYXJlbnRFbG0sIGNoLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIGNicy5yZW1vdmVbaV0oY2gsIHJtKTtcbiAgICAgICAgaWYgKCFpc1VuZGVmKGkgPSBjaC5kYXRhKSAmJiAhaXNVbmRlZihpID0gaS5ob29rKSAmJiAhaXNVbmRlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgICAgaShjaCwgcm0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJtKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDAsIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgYmVmb3JlO1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKTtcbiAgICAgICAgcGFyZW50RWxtLmluc2VydEJlZm9yZShvbGRTdGFydFZub2RlLmVsbSwgb2xkRW5kVm5vZGUuZWxtLm5leHRTaWJsaW5nKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpO1xuICAgICAgICBwYXJlbnRFbG0uaW5zZXJ0QmVmb3JlKG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWR4SW5PbGQgPSBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV07XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUoY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUpLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSk7XG4gICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHBhcmVudEVsbS5pbnNlcnRCZWZvcmUoZWxtVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIGJlZm9yZSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4KzFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHgrMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgYmVmb3JlLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIGksIGhvb2s7XG4gICAgaWYgKCFpc1VuZGVmKGkgPSB2bm9kZS5kYXRhKSAmJiAhaXNVbmRlZihob29rID0gaS5ob29rKSAmJiAhaXNVbmRlZihpID0gaG9vay5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmKGkgPSBvbGRWbm9kZS5kYXRhKSAmJiAhaXNVbmRlZihpID0gaS52bm9kZSkpIG9sZFZub2RlID0gaTtcbiAgICBpZiAoIWlzVW5kZWYoaSA9IHZub2RlLmRhdGEpICYmICFpc1VuZGVmKGkgPSBpLnZub2RlKSkgdm5vZGUgPSBpO1xuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG0sIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW4sIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkgcmV0dXJuO1xuICAgIGlmICghaXNVbmRlZih2bm9kZS5kYXRhKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7XG4gICAgICBpZiAoIWlzVW5kZWYoaSkgJiYgIWlzVW5kZWYoaSA9IGkudXBkYXRlKSkgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKCFpc1VuZGVmKG9sZENoKSAmJiAhaXNVbmRlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gpO1xuICAgICAgfSBlbHNlIGlmICghaXNVbmRlZihjaCkpIHtcbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmICghaXNVbmRlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLnRleHRDb250ZW50ID0gdm5vZGUudGV4dDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmKGhvb2spICYmICFpc1VuZGVmKGkgPSBob29rLnBvc3RwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuICAgIGlmIChvbGRWbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnByZS5sZW5ndGg7ICsraSkgY2JzLnByZVtpXSgpO1xuICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWVbaV0uZGF0YS5ob29rLmluc2VydChpbnNlcnRlZFZub2RlUXVldWVbaV0pO1xuICAgIH1cbiAgICBpbnNlcnRlZFZub2RlUXVldWUgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGNicy5wb3N0Lmxlbmd0aDsgKytpKSBjYnMucG9zdFtpXSgpO1xuICAgIHJldHVybiB2bm9kZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7aW5pdDogaW5pdH07XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgc25hYmJkb20gPSByZXF1aXJlKCcuLi9zbmFiYmRvbScpO1xuXG52YXIgcGF0Y2ggPSBzbmFiYmRvbS5pbml0KFtdKTtcbnZhciBhdHRhY2hUbyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYXR0YWNodG8nKTtcbnZhciBoID0gcmVxdWlyZSgnLi4vaCcpO1xuXG5kZXNjcmliZSgnYXR0YWNoVG8nLCBmdW5jdGlvbigpIHtcbiAgdmFyIGVsbSwgdm5vZGUwO1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZub2RlMCA9IGVsbTtcbiAgfSk7XG4gIGl0KCdhZGRzIGVsZW1lbnQgdG8gdGFyZ2V0JywgZnVuY3Rpb24oKSB7XG4gICAgcGF0Y2godm5vZGUwLCBoKCdkaXYnLCBbXG4gICAgICBoKCdkaXYjd3JhcHBlcicsIFtcbiAgICAgICAgaCgnZGl2JywgJ1NvbWUgZWxlbWVudCcpLFxuICAgICAgICBhdHRhY2hUbyhlbG0sIGgoJ2RpdiNhdHRhY2hlZCcsICdUZXN0JykpLFxuICAgICAgXSksXG4gICAgXSkpO1xuICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCAyKTtcbiAgfSk7XG4gIGl0KCd1cGRhdGVzIGVsZW1lbnQgYXQgdGFyZ2V0JywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZub2RlMSA9IGgoJ2RpdicsIFtcbiAgICAgIGgoJ2RpdiN3cmFwcGVyJywgW1xuICAgICAgICBoKCdkaXYnLCAnU29tZSBlbGVtZW50JyksXG4gICAgICAgIGF0dGFjaFRvKGVsbSwgaCgnZGl2I2F0dGFjaGVkJywgJ0ZpcnN0IHRleHQnKSksXG4gICAgICBdKSxcbiAgICBdKTtcbiAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW1xuICAgICAgaCgnZGl2I3dyYXBwZXInLCBbXG4gICAgICAgIGgoJ2RpdicsICdTb21lIGVsZW1lbnQnKSxcbiAgICAgICAgYXR0YWNoVG8oZWxtLCBoKCdkaXYjYXR0YWNoZWQnLCAnTmV3IHRleHQnKSksXG4gICAgICBdKSxcbiAgICBdKTtcbiAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblswXS5pbm5lckhUTUwsICdGaXJzdCB0ZXh0Jyk7XG4gICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MLCAnTmV3IHRleHQnKTtcbiAgfSk7XG4gIGl0KCdlbGVtZW50IGNhbiBiZSBpbnNlcnRlZCBiZWZvcmUgbW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW1xuICAgICAgaCgnZGl2I3dyYXBwZXInLCBbXG4gICAgICAgIGgoJ2RpdicsICdTb21lIGVsZW1lbnQnKSxcbiAgICAgICAgYXR0YWNoVG8oZWxtLCBoKCdkaXYjYXR0YWNoZWQnLCAnVGV4dCcpKSxcbiAgICAgIF0pLFxuICAgIF0pO1xuICAgIHZhciB2bm9kZTIgPSBoKCdkaXYnLCBbXG4gICAgICBoKCdkaXYjd3JhcHBlcicsIFtcbiAgICAgICAgaCgnZGl2JywgJ1NvbWUgZWxlbWVudCcpLFxuICAgICAgICBoKCdkaXYnLCAnQSBuZXcgZWxlbWVudCcpLFxuICAgICAgICBhdHRhY2hUbyhlbG0sIGgoJ2RpdiNhdHRhY2hlZCcsICdUZXh0JykpLFxuICAgICAgXSksXG4gICAgXSk7XG4gICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MLCAnVGV4dCcpO1xuICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzBdLmlubmVySFRNTCwgJ1RleHQnKTtcbiAgfSk7XG4gIGl0KCdyZW1vdmVzIGVsZW1lbnQgYXQgdGFyZ2V0JywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZub2RlMSA9IGgoJ2RpdicsIFtcbiAgICAgIGgoJ2RpdiN3cmFwcGVyJywgW1xuICAgICAgICBoKCdkaXYnLCAnU29tZSBlbGVtZW50JyksXG4gICAgICAgIGF0dGFjaFRvKGVsbSwgaCgnZGl2I2F0dGFjaGVkJywgJ0ZpcnN0IHRleHQnKSksXG4gICAgICBdKSxcbiAgICBdKTtcbiAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW1xuICAgICAgaCgnZGl2I3dyYXBwZXInLCBbXG4gICAgICAgIGgoJ2RpdicsICdTb21lIGVsZW1lbnQnKSxcbiAgICAgIF0pLFxuICAgIF0pO1xuICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzBdLmlubmVySFRNTCwgJ0ZpcnN0IHRleHQnKTtcbiAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDEpO1xuICB9KTtcbn0pO1xuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIHNodWZmbGUgPSByZXF1aXJlKCdrbnV0aC1zaHVmZmxlJykua251dGhTaHVmZmxlO1xuXG52YXIgc25hYmJkb20gPSByZXF1aXJlKCcuLi9zbmFiYmRvbScpO1xudmFyIHBhdGNoID0gc25hYmJkb20uaW5pdChbXG4gIHJlcXVpcmUoJy4uL21vZHVsZXMvY2xhc3MnKSxcbiAgcmVxdWlyZSgnLi4vbW9kdWxlcy9wcm9wcycpLFxuICByZXF1aXJlKCcuLi9tb2R1bGVzL2V2ZW50bGlzdGVuZXJzJyksXG5dKTtcbnZhciBoID0gcmVxdWlyZSgnLi4vaCcpO1xuXG5mdW5jdGlvbiBwcm9wKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmpbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcChmbiwgbGlzdCkge1xuICB2YXIgcmV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGZuKGxpc3RbaV0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbnZhciBpbm5lciA9IHByb3AoJ2lubmVySFRNTCcpO1xuXG5kZXNjcmliZSgnc25hYmJkb20nLCBmdW5jdGlvbigpIHtcbiAgdmFyIGVsbSwgdm5vZGUwO1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZub2RlMCA9IGVsbTtcbiAgfSk7XG4gIGRlc2NyaWJlKCdoeXBlcnNjcmlwdCcsIGZ1bmN0aW9uKCkge1xuICAgIGl0KCdjYW4gY3JlYXRlIHZub2RlIHdpdGggcHJvcGVyIHRhZycsIGZ1bmN0aW9uKCkge1xuICAgICAgYXNzZXJ0LmVxdWFsKGgoJ2RpdicpLnNlbCwgJ2RpdicpO1xuICAgICAgYXNzZXJ0LmVxdWFsKGgoJ2EnKS5zZWwsICdhJyk7XG4gICAgfSk7XG4gICAgaXQoJ2NhbiBjcmVhdGUgdm5vZGUgd2l0aCBjaGlsZHJlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZub2RlID0gaCgnZGl2JywgW2goJ3NwYW4jaGVsbG8nKSwgaCgnYi53b3JsZCcpXSk7XG4gICAgICBhc3NlcnQuZXF1YWwodm5vZGUuc2VsLCAnZGl2Jyk7XG4gICAgICBhc3NlcnQuZXF1YWwodm5vZGUuY2hpbGRyZW5bMF0uc2VsLCAnc3BhbiNoZWxsbycpO1xuICAgICAgYXNzZXJ0LmVxdWFsKHZub2RlLmNoaWxkcmVuWzFdLnNlbCwgJ2Iud29ybGQnKTtcbiAgICB9KTtcbiAgICBpdCgnY2FuIGNyZWF0ZSB2bm9kZSB3aXRoIHRleHQgY29udGVudCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZub2RlID0gaCgnYScsIFsnSSBhbSBhIHN0cmluZyddKTtcbiAgICAgIGFzc2VydC5lcXVhbCh2bm9kZS5jaGlsZHJlblswXS50ZXh0LCAnSSBhbSBhIHN0cmluZycpO1xuICAgIH0pO1xuICAgIGl0KCdjYW4gY3JlYXRlIHZub2RlIHdpdGggdGV4dCBjb250ZW50IGluIHN0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZub2RlID0gaCgnYScsICdJIGFtIGEgc3RyaW5nJyk7XG4gICAgICBhc3NlcnQuZXF1YWwodm5vZGUudGV4dCwgJ0kgYW0gYSBzdHJpbmcnKTtcbiAgICB9KTtcbiAgICBpdCgnY2FuIGNyZWF0ZSB2bm9kZSB3aXRoIHByb3BzIGFuZCB0ZXh0IGNvbnRlbnQgaW4gc3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdm5vZGUgPSBoKCdhJywge30sICdJIGFtIGEgc3RyaW5nJyk7XG4gICAgICBhc3NlcnQuZXF1YWwodm5vZGUudGV4dCwgJ0kgYW0gYSBzdHJpbmcnKTtcbiAgICB9KTtcbiAgfSk7XG4gIGRlc2NyaWJlKCdjcmVhdGVkIGVsZW1lbnQnLCBmdW5jdGlvbigpIHtcbiAgICBpdCgnaGFzIHRhZycsIGZ1bmN0aW9uKCkge1xuICAgICAgcGF0Y2godm5vZGUwLCBoKCdkaXYnKSk7XG4gICAgICBhc3NlcnQuZXF1YWwoZWxtLnRhZ05hbWUsICdESVYnKTtcbiAgICB9KTtcbiAgICBpdCgnaGFzIGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICBwYXRjaCh2bm9kZTAsIGgoJ2RpdicsIFtoKCdkaXYjdW5pcXVlJyldKSk7XG4gICAgICBhc3NlcnQuZXF1YWwoZWxtLmZpcnN0Q2hpbGQuaWQsICd1bmlxdWUnKTtcbiAgICB9KTtcbiAgICBpdCgnaGFzIGNvcnJlY3QgbmFtZXNwYWNlJywgZnVuY3Rpb24oKSB7XG4gICAgICBwYXRjaCh2bm9kZTAsIGgoJ2RpdicsIFtoKCdkaXYnLCB7bnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyd9KV0pKTtcbiAgICAgIGFzc2VydC5lcXVhbChlbG0uZmlyc3RDaGlsZC5uYW1lc3BhY2VVUkksICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpO1xuICAgIH0pO1xuICAgIGl0KCdpcyByZWNpZXZlcyBjbGFzc2VzIGluIHNlbGVjdG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICBwYXRjaCh2bm9kZTAsIGgoJ2RpdicsIFtoKCdpLmFtLmEuY2xhc3MnKV0pKTtcbiAgICAgIGFzc2VydChlbG0uZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2FtJykpO1xuICAgICAgYXNzZXJ0KGVsbS5maXJzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucygnYScpKTtcbiAgICAgIGFzc2VydChlbG0uZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2NsYXNzJykpO1xuICAgIH0pO1xuICAgIGl0KCdpcyByZWNpZXZlcyBjbGFzc2VzIGluIGNsYXNzIHByb3BlcnR5JywgZnVuY3Rpb24oKSB7XG4gICAgICBwYXRjaCh2bm9kZTAsIGgoJ2knLCB7Y2xhc3M6IHthbTogdHJ1ZSwgYTogdHJ1ZSwgY2xhc3M6IHRydWUsIG5vdDogZmFsc2V9fSkpO1xuICAgICAgYXNzZXJ0KGVsbS5jbGFzc0xpc3QuY29udGFpbnMoJ2FtJykpO1xuICAgICAgYXNzZXJ0KGVsbS5jbGFzc0xpc3QuY29udGFpbnMoJ2EnKSk7XG4gICAgICBhc3NlcnQoZWxtLmNsYXNzTGlzdC5jb250YWlucygnY2xhc3MnKSk7XG4gICAgICBhc3NlcnQoIWVsbS5jbGFzc0xpc3QuY29udGFpbnMoJ25vdCcpKTtcbiAgICB9KTtcbiAgICBpdCgnaGFuZGxlcyBjbGFzc2VzIGZyb20gYm90aCBzZWxlY3RvciBhbmQgcHJvcGVydHknLCBmdW5jdGlvbigpIHtcbiAgICAgIHBhdGNoKHZub2RlMCwgaCgnZGl2JywgW2goJ2kuaGFzJywge2NsYXNzOiB7Y2xhc3NlczogdHJ1ZX19KV0pKTtcbiAgICAgIGFzc2VydChlbG0uZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2hhcycpKTtcbiAgICAgIGFzc2VydChlbG0uZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2NsYXNzZXMnKSk7XG4gICAgfSk7XG4gICAgaXQoJ2NhbiBjcmVhdGUgZWxlbWVudHMgd2l0aCB0ZXh0IGNvbnRlbnQnLCBmdW5jdGlvbigpIHtcbiAgICAgIHBhdGNoKHZub2RlMCwgaCgnZGl2JywgWydJIGFtIGEgc3RyaW5nJ10pKTtcbiAgICAgIGFzc2VydC5lcXVhbChlbG0uaW5uZXJIVE1MLCAnSSBhbSBhIHN0cmluZycpO1xuICAgIH0pO1xuICAgIGl0KCdjYW4gY3JlYXRlIGVsZW1lbnRzIHdpdGggc3BhbiBhbmQgdGV4dCBjb250ZW50JywgZnVuY3Rpb24oKSB7XG4gICAgICBwYXRjaCh2bm9kZTAsIGgoJ2EnLCBbaCgnc3BhbicpLCAnSSBhbSBhIHN0cmluZyddKSk7XG4gICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkTm9kZXNbMF0udGFnTmFtZSwgJ1NQQU4nKTtcbiAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGROb2Rlc1sxXS50ZXh0Q29udGVudCwgJ0kgYW0gYSBzdHJpbmcnKTtcbiAgICB9KTtcbiAgfSk7XG4gIGRlc2NyaWJlKCdwYXRoaW5nIGFuIGVsZW1lbnQnLCBmdW5jdGlvbigpIHtcbiAgICBpdCgnY2hhbmdlcyB0aGUgZWxlbWVudHMgY2xhc3NlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZub2RlMSA9IGgoJ2knLCB7Y2xhc3M6IHtpOiB0cnVlLCBhbTogdHJ1ZSwgaG9yc2U6IHRydWV9fSk7XG4gICAgICB2YXIgdm5vZGUyID0gaCgnaScsIHtjbGFzczoge2k6IHRydWUsIGFtOiB0cnVlLCBob3JzZTogZmFsc2V9fSk7XG4gICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICBhc3NlcnQoZWxtLmNsYXNzTGlzdC5jb250YWlucygnaScpKTtcbiAgICAgIGFzc2VydChlbG0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhbScpKTtcbiAgICAgIGFzc2VydCghZWxtLmNsYXNzTGlzdC5jb250YWlucygnaG9yc2UnKSk7XG4gICAgfSk7XG4gICAgaXQoJ2NoYW5nZXMgY2xhc3NlcyBpbiBzZWxlY3RvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZub2RlMSA9IGgoJ2knLCB7Y2xhc3M6IHtpOiB0cnVlLCBhbTogdHJ1ZSwgaG9yc2U6IHRydWV9fSk7XG4gICAgICB2YXIgdm5vZGUyID0gaCgnaScsIHtjbGFzczoge2k6IHRydWUsIGFtOiB0cnVlLCBob3JzZTogZmFsc2V9fSk7XG4gICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICBhc3NlcnQoZWxtLmNsYXNzTGlzdC5jb250YWlucygnaScpKTtcbiAgICAgIGFzc2VydChlbG0uY2xhc3NMaXN0LmNvbnRhaW5zKCdhbScpKTtcbiAgICAgIGFzc2VydCghZWxtLmNsYXNzTGlzdC5jb250YWlucygnaG9yc2UnKSk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ3VwZGF0aW5nIGNoaWxkcmVuIHdpdGgga2V5cycsIGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gc3Bhbk51bShuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gaCgnc3BhbicsIHt9LCBuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaCgnc3BhbicsIHtrZXk6IG59LCBuLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZXNjcmliZSgnYWRkaXRpb24gb2YgZWxlbWVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ2FwcGVuZHMgZWxlbWVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdm5vZGUxID0gaCgnc3BhbicsIFsxXS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHZhciB2bm9kZTIgPSBoKCdzcGFuJywgWzEsIDIsIDNdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCAxKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDMpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMV0uaW5uZXJIVE1MLCAnMicpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMl0uaW5uZXJIVE1MLCAnMycpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3ByZXBlbmRzIGVsZW1lbnRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZub2RlMSA9IGgoJ3NwYW4nLCBbNCwgNV0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIFsxLCAyLCAzLCA0LCA1XS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgMik7XG4gICAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwobWFwKGlubmVyLCBlbG0uY2hpbGRyZW4pLCBbJzEnLCAnMicsICczJywgJzQnLCAnNSddKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdhZGQgZWxlbWVudHMgaW4gdGhlIG1pZGRsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2bm9kZTEgPSBoKCdzcGFuJywgWzEsIDIsIDQsIDVdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgICAgdmFyIHZub2RlMiA9IGgoJ3NwYW4nLCBbMSwgMiwgMywgNCwgNV0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDQpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCA0KTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChtYXAoaW5uZXIsIGVsbS5jaGlsZHJlbiksIFsnMScsICcyJywgJzMnLCAnNCcsICc1J10pO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ2FkZCBlbGVtZW50cyBhdCBiZWdpbiBhbmQgZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZub2RlMSA9IGgoJ3NwYW4nLCBbMiwgMywgNF0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIFsxLCAyLCAzLCA0LCA1XS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgMyk7XG4gICAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwobWFwKGlubmVyLCBlbG0uY2hpbGRyZW4pLCBbJzEnLCAnMicsICczJywgJzQnLCAnNSddKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdhZGRzIGNoaWxkcmVuIHRvIHBhcmVudCB3aXRoIG5vIGNoaWxkcmVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZub2RlMSA9IGgoJ3NwYW4nLCB7a2V5OiAnc3Bhbid9KTtcbiAgICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIHtrZXk6ICdzcGFuJ30sIFsxLCAyLCAzXS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgMCk7XG4gICAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwobWFwKGlubmVyLCBlbG0uY2hpbGRyZW4pLCBbJzEnLCAnMicsICczJ10pO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3JlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gcGFyZW50JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZub2RlMSA9IGgoJ3NwYW4nLCB7a2V5OiAnc3Bhbid9LCBbMSwgMiwgM10ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIHtrZXk6ICdzcGFuJ30pO1xuICAgICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKG1hcChpbm5lciwgZWxtLmNoaWxkcmVuKSwgWycxJywgJzInLCAnMyddKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZGVzY3JpYmUoJ3JlbW92YWwgb2YgZWxlbWVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3JlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZub2RlMSA9IGgoJ3NwYW4nLCBbMSwgMiwgMywgNCwgNV0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIFszLCA0LCA1XS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgNSk7XG4gICAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwobWFwKGlubmVyLCBlbG0uY2hpbGRyZW4pLCBbJzMnLCAnNCcsICc1J10pO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3JlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZub2RlMSA9IGgoJ3NwYW4nLCBbMSwgMiwgMywgNCwgNV0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIFsxLCAyLCAzXS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgNSk7XG4gICAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCAzKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzBdLmlubmVySFRNTCwgJzEnKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzFdLmlubmVySFRNTCwgJzInKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzJdLmlubmVySFRNTCwgJzMnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdyZW1vdmVzIGVsZW1lbnRzIGZyb20gdGhlIG1pZGRsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2bm9kZTEgPSBoKCdzcGFuJywgWzEsIDIsIDMsIDQsIDVdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgICAgdmFyIHZub2RlMiA9IGgoJ3NwYW4nLCBbMSwgMiwgNCwgNV0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDUpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgNCk7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChlbG0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MLCAnMScpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MLCAnMScpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMV0uaW5uZXJIVE1MLCAnMicpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMl0uaW5uZXJIVE1MLCAnNCcpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bM10uaW5uZXJIVE1MLCAnNScpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZGVzY3JpYmUoJ2VsZW1lbnQgcmVvcmRlcmluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnbW92ZXMgZWxlbWVudCBmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZub2RlMSA9IGgoJ3NwYW4nLCBbMSwgMiwgMywgNF0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIFsyLCAzLCAxLCA0XS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgNCk7XG4gICAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCA0KTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzBdLmlubmVySFRNTCwgJzInKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzFdLmlubmVySFRNTCwgJzMnKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzJdLmlubmVySFRNTCwgJzEnKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzNdLmlubmVySFRNTCwgJzQnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdtb3ZlcyBlbGVtZW50IHRvIGVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2bm9kZTEgPSBoKCdzcGFuJywgWzEsIDIsIDNdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgICAgdmFyIHZub2RlMiA9IGgoJ3NwYW4nLCBbMiwgMywgMV0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDMpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgMyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblswXS5pbm5lckhUTUwsICcyJyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblsxXS5pbm5lckhUTUwsICczJyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblsyXS5pbm5lckhUTUwsICcxJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnbW92ZXMgZWxlbWVudCBiYWNrd2FyZHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdm5vZGUxID0gaCgnc3BhbicsIFsxLCAyLCAzLCA0XS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHZhciB2bm9kZTIgPSBoKCdzcGFuJywgWzEsIDQsIDIsIDNdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCA0KTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDQpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMF0uaW5uZXJIVE1MLCAnMScpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMV0uaW5uZXJIVE1MLCAnNCcpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bMl0uaW5uZXJIVE1MLCAnMicpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5bM10uaW5uZXJIVE1MLCAnMycpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3N3YXBzIGZpcnN0IGFuZCBsYXN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZub2RlMSA9IGgoJ3NwYW4nLCBbMSwgMiwgMywgNF0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIFs0LCAyLCAzLCAxXS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgNCk7XG4gICAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCA0KTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzBdLmlubmVySFRNTCwgJzQnKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzFdLmlubmVySFRNTCwgJzInKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzJdLmlubmVySFRNTCwgJzMnKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuWzNdLmlubmVySFRNTCwgJzEnKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGRlc2NyaWJlKCdjb21iaW5hdGlvbnMgb2YgYWRkaXRpb25zLCByZW1vdmFscyBhbmQgcmVvcmRlcmluZ3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ21vdmUgdG8gbGVmdCBhbmQgcmVwbGFjZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2bm9kZTEgPSBoKCdzcGFuJywgWzEsIDIsIDMsIDQsIDVdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgICAgdmFyIHZub2RlMiA9IGgoJ3NwYW4nLCBbNCwgMSwgMiwgMywgNl0ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDUpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgNSk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblswXS5pbm5lckhUTUwsICc0Jyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblsxXS5pbm5lckhUTUwsICcxJyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblsyXS5pbm5lckhUTUwsICcyJyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblszXS5pbm5lckhUTUwsICczJyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbls0XS5pbm5lckhUTUwsICc2Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnbW92ZXMgdG8gbGVmdCBhbmQgbGVhdmVzIGhvbGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdm5vZGUxID0gaCgnc3BhbicsIFsxLCA0LCA1XS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICAgIHZhciB2bm9kZTIgPSBoKCdzcGFuJywgWzQsIDZdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCAzKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChtYXAoaW5uZXIsIGVsbS5jaGlsZHJlbiksIFsnNCcsICc2J10pO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ2hhbmRsZXMgbW92ZWQgYW5kIHNldCB0byB1bmRlZmluZWQgZWxlbWVudCBlbmRpbmcgYXQgdGhlIGVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2bm9kZTEgPSBoKCdzcGFuJywgWzIsIDQsIDVdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgICAgdmFyIHZub2RlMiA9IGgoJ3NwYW4nLCBbNCwgNSwgM10ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDMpO1xuICAgICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkcmVuLmxlbmd0aCwgMyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblswXS5pbm5lckhUTUwsICc0Jyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblsxXS5pbm5lckhUTUwsICc1Jyk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlblsyXS5pbm5lckhUTUwsICczJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnbW92ZXMgYSBrZXkgaW4gbm9uLWtleWVkIG5vZGVzIHdpdGggYSBzaXplIHVwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZub2RlMSA9IGgoJ3NwYW4nLCBbMSwgJ2EnLCAnYicsICdjJ10ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIFsnZCcsICdhJywgJ2InLCAnYycsIDEsICdlJ10ubWFwKHNwYW5OdW0pKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCwgNCk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS50ZXh0Q29udGVudCwgJzFhYmMnKTtcbiAgICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCwgNik7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS50ZXh0Q29udGVudCwgJ2RhYmMxZScpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ3JldmVyc2VzIGVsZW1lbnRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2bm9kZTEgPSBoKCdzcGFuJywgWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgIHZhciB2bm9kZTIgPSBoKCdzcGFuJywgWzgsIDcsIDYsIDUsIDQsIDMsIDIsIDFdLm1hcChzcGFuTnVtKSk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDgpO1xuICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwobWFwKGlubmVyLCBlbG0uY2hpbGRyZW4pLCBbJzgnLCAnNycsICc2JywgJzUnLCAnNCcsICczJywgJzInLCAnMSddKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ3NvbWV0aGluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnc3BhbicsIFswLCAxLCAyLCAzLCA0LCA1XS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICB2YXIgdm5vZGUyID0gaCgnc3BhbicsIFs0LCAzLCAyLCAxLCA1LCAwXS5tYXAoc3Bhbk51bSkpO1xuICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCA2KTtcbiAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKG1hcChpbm5lciwgZWxtLmNoaWxkcmVuKSwgWyc0JywgJzMnLCAnMicsICcxJywgJzUnLCAnMCddKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ2hhbmRsZXMgcmFuZG9tIHNodWZmbGVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuLCBpLCBhcnIgPSBbXSwgb3BhY2l0aWVzID0gW10sIGVsbXMgPSAxNCwgc2FtcGxlcyA9IDU7XG4gICAgICAgIGZ1bmN0aW9uIHNwYW5OdW1XaXRoT3BhY2l0eShuLCBvKSB7XG4gICAgICAgICAgcmV0dXJuIGgoJ3NwYW4nLCB7a2V5OiBuLCBzdHlsZToge29wYWNpdHk6IG99fSwgbi50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgZWxtczsgKytuKSB7IGFycltuXSA9IG47IH1cbiAgICAgICAgZm9yIChuID0gMDsgbiA8IHNhbXBsZXM7ICsrbikge1xuICAgICAgICAgIHZhciB2bm9kZTEgPSBoKCdzcGFuJywgYXJyLm1hcChmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Bhbk51bVdpdGhPcGFjaXR5KG4sICcxJyk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciBzaHVmQXJyID0gc2h1ZmZsZShhcnIuc2xpY2UoMCkpO1xuICAgICAgICAgIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBwYXRjaChlbG0sIHZub2RlMSk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsbXM7ICsraSkge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbltpXS5pbm5lckhUTUwsIGkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBvcGFjaXRpZXNbaV0gPSBNYXRoLnJhbmRvbSgpLnRvRml4ZWQoNSkudG9TdHJpbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZub2RlMiA9IGgoJ3NwYW4nLCBhcnIubWFwKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBzcGFuTnVtV2l0aE9wYWNpdHkoc2h1ZkFycltuXSwgb3BhY2l0aWVzW25dKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbG1zOyArK2kpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW5baV0uaW5uZXJIVE1MLCBzaHVmQXJyW2ldLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9wYWNpdGllc1tpXS5pbmRleE9mKGVsbS5jaGlsZHJlbltpXS5zdHlsZS5vcGFjaXR5KSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgndXBkYXRpbmcgY2hpbGRyZW4gd2l0aG91dCBrZXlzJywgZnVuY3Rpb24oKSB7XG4gICAgICBpdCgnYXBwZW5kcyBlbGVtZW50cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW2goJ3NwYW4nLCAnSGVsbG8nKV0pO1xuICAgICAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW2goJ3NwYW4nLCAnSGVsbG8nKSwgaCgnc3BhbicsICdXb3JsZCcpXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChtYXAoaW5uZXIsIGVsbS5jaGlsZHJlbiksIFsnSGVsbG8nXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChtYXAoaW5uZXIsIGVsbS5jaGlsZHJlbiksIFsnSGVsbG8nLCAnV29ybGQnXSk7XG4gICAgICB9KTtcbiAgICAgIGl0KCdoYW5kbGVzIHVubW92ZWQgdGV4dCBub2RlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgWydUZXh0JywgaCgnc3BhbicsICdTcGFuJyldKTtcbiAgICAgICAgdmFyIHZub2RlMiA9IGgoJ2RpdicsIFsnVGV4dCcsIGgoJ3NwYW4nLCAnU3BhbicpXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZE5vZGVzWzBdLnRleHRDb250ZW50LCAnVGV4dCcpO1xuICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGROb2Rlc1swXS50ZXh0Q29udGVudCwgJ1RleHQnKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ2hhbmRsZXMgY2hhbmdpbmcgdGV4dCBjaGlsZHJlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgWydUZXh0JywgaCgnc3BhbicsICdTcGFuJyldKTtcbiAgICAgICAgdmFyIHZub2RlMiA9IGgoJ2RpdicsIFsnVGV4dDInLCBoKCdzcGFuJywgJ1NwYW4nKV0pO1xuICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGROb2Rlc1swXS50ZXh0Q29udGVudCwgJ1RleHQnKTtcbiAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICBhc3NlcnQuZXF1YWwoZWxtLmNoaWxkTm9kZXNbMF0udGV4dENvbnRlbnQsICdUZXh0MicpO1xuICAgICAgfSk7XG4gICAgICBpdCgncHJlcGVuZHMgZWxlbWVudCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW2goJ3NwYW4nLCAnV29ybGQnKV0pO1xuICAgICAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW2goJ3NwYW4nLCAnSGVsbG8nKSwgaCgnc3BhbicsICdXb3JsZCcpXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChtYXAoaW5uZXIsIGVsbS5jaGlsZHJlbiksIFsnV29ybGQnXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChtYXAoaW5uZXIsIGVsbS5jaGlsZHJlbiksIFsnSGVsbG8nLCAnV29ybGQnXSk7XG4gICAgICB9KTtcbiAgICAgIGl0KCdwcmVwZW5kcyBlbGVtZW50IG9mIGRpZmZlcmVudCB0YWcgdHlwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW2goJ3NwYW4nLCAnV29ybGQnKV0pO1xuICAgICAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW2goJ2RpdicsICdIZWxsbycpLCBoKCdzcGFuJywgJ1dvcmxkJyldKTtcbiAgICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKG1hcChpbm5lciwgZWxtLmNoaWxkcmVuKSwgWydXb3JsZCddKTtcbiAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKG1hcChwcm9wKCd0YWdOYW1lJyksIGVsbS5jaGlsZHJlbiksIFsnRElWJywgJ1NQQU4nXSk7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwobWFwKGlubmVyLCBlbG0uY2hpbGRyZW4pLCBbJ0hlbGxvJywgJ1dvcmxkJ10pO1xuICAgICAgfSk7XG4gICAgICBpdCgncmVtb3ZlcyBlbGVtZW50cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW2goJ3NwYW4nLCAnT25lJyksIGgoJ3NwYW4nLCAnVHdvJyksIGgoJ3NwYW4nLCAnVGhyZWUnKV0pO1xuICAgICAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW2goJ3NwYW4nLCAnT25lJyksIGgoJ3NwYW4nLCAnVGhyZWUnKV0pO1xuICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwobWFwKGlubmVyLCBlbG0uY2hpbGRyZW4pLCBbJ09uZScsICdUd28nLCAnVGhyZWUnXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChtYXAoaW5uZXIsIGVsbS5jaGlsZHJlbiksIFsnT25lJywgJ1RocmVlJ10pO1xuICAgICAgfSk7XG4gICAgICBpdCgncmVvcmRlcnMgZWxlbWVudHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZub2RlMSA9IGgoJ2RpdicsIFtoKCdzcGFuJywgJ09uZScpLCBoKCdkaXYnLCAnVHdvJyksIGgoJ2InLCAnVGhyZWUnKV0pO1xuICAgICAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW2goJ2InLCAnVGhyZWUnKSwgaCgnc3BhbicsICdPbmUnKSwgaCgnZGl2JywgJ1R3bycpXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChtYXAoaW5uZXIsIGVsbS5jaGlsZHJlbiksIFsnT25lJywgJ1R3bycsICdUaHJlZSddKTtcbiAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKG1hcChwcm9wKCd0YWdOYW1lJyksIGVsbS5jaGlsZHJlbiksIFsnQicsICdTUEFOJywgJ0RJViddKTtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChtYXAoaW5uZXIsIGVsbS5jaGlsZHJlbiksIFsnVGhyZWUnLCAnT25lJywgJ1R3byddKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgZGVzY3JpYmUoJ2V2ZW50IGhhbmRsaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgaXQoJ2F0dGFjaGVzIGNsaWNrIGV2ZW50IGhhbmRsZXIgdG8gZWxlbWVudCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZnVuY3Rpb24gY2xpY2tlZChldikgeyByZXN1bHQucHVzaChldik7IH1cbiAgICAgIHZhciB2bm9kZSA9IGgoJ2RpdicsIHtvbjoge2NsaWNrOiBjbGlja2VkfX0sIFtcbiAgICAgICAgaCgnYScsICdDbGljayBteSBwYXJlbnQnKSxcbiAgICAgIF0pO1xuICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZSk7XG4gICAgICBlbG0uY2xpY2soKTtcbiAgICAgIGFzc2VydC5lcXVhbCgxLCByZXN1bHQubGVuZ3RoKTtcbiAgICB9KTtcbiAgICBpdCgnZG9lcyBub3QgYXR0YWNoIG5ldyBsaXN0ZW5lcicsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgLy9mdW5jdGlvbiBjbGlja2VkKGV2KSB7IHJlc3VsdC5wdXNoKGV2KTsgfVxuICAgICAgdmFyIHZub2RlMSA9IGgoJ2RpdicsIHtvbjoge2NsaWNrOiBmdW5jdGlvbihldikgeyByZXN1bHQucHVzaCgxKTsgfX19LCBbXG4gICAgICAgIGgoJ2EnLCAnQ2xpY2sgbXkgcGFyZW50JyksXG4gICAgICBdKTtcbiAgICAgIHZhciB2bm9kZTIgPSBoKCdkaXYnLCB7b246IHtjbGljazogZnVuY3Rpb24oZXYpIHsgcmVzdWx0LnB1c2goMik7IH19fSwgW1xuICAgICAgICBoKCdhJywgJ0NsaWNrIG15IHBhcmVudCcpLFxuICAgICAgXSk7XG4gICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICBlbG0uY2xpY2soKTtcbiAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgIGVsbS5jbGljaygpO1xuICAgICAgYXNzZXJ0LmRlZXBFcXVhbChyZXN1bHQsIFsxLCAyXSk7XG4gICAgfSk7XG4gICAgaXQoJ2RvZXMgY2FsbHMgaGFuZGxlciBmb3IgZnVuY3Rpb24gaW4gYXJyYXknLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGNsaWNrZWQoZXYpIHsgcmVzdWx0LnB1c2goZXYpOyB9XG4gICAgICB2YXIgdm5vZGUgPSBoKCdkaXYnLCB7b246IHtjbGljazogW2NsaWNrZWQsIDFdfX0sIFtcbiAgICAgICAgaCgnYScsICdDbGljayBteSBwYXJlbnQnKSxcbiAgICAgIF0pO1xuICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZSk7XG4gICAgICBlbG0uY2xpY2soKTtcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwocmVzdWx0LCBbMV0pO1xuICAgIH0pO1xuICAgIGl0KCdoYW5kbGVzIGNoYW5nZWQgdmFsdWUgaW4gYXJyYXknLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGNsaWNrZWQoZXYpIHsgcmVzdWx0LnB1c2goZXYpOyB9XG4gICAgICB2YXIgdm5vZGUxID0gaCgnZGl2Jywge29uOiB7Y2xpY2s6IFtjbGlja2VkLCAxXX19LCBbXG4gICAgICAgIGgoJ2EnLCAnQ2xpY2sgbXkgcGFyZW50JyksXG4gICAgICBdKTtcbiAgICAgIHZhciB2bm9kZTIgPSBoKCdkaXYnLCB7b246IHtjbGljazogW2NsaWNrZWQsIDJdfX0sIFtcbiAgICAgICAgaCgnYScsICdDbGljayBteSBwYXJlbnQnKSxcbiAgICAgIF0pO1xuICAgICAgdmFyIHZub2RlMyA9IGgoJ2RpdicsIHtvbjoge2NsaWNrOiBbY2xpY2tlZCwgM119fSwgW1xuICAgICAgICBoKCdhJywgJ0NsaWNrIG15IHBhcmVudCcpLFxuICAgICAgXSk7XG4gICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICBlbG0uY2xpY2soKTtcbiAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgIGVsbS5jbGljaygpO1xuICAgICAgcGF0Y2godm5vZGUyLCB2bm9kZTMpO1xuICAgICAgZWxtLmNsaWNrKCk7XG4gICAgICBhc3NlcnQuZGVlcEVxdWFsKHJlc3VsdCwgWzEsIDIsIDNdKTtcbiAgICB9KTtcbiAgfSk7XG4gIGRlc2NyaWJlKCdob29rcycsIGZ1bmN0aW9uKCkge1xuICAgIGRlc2NyaWJlKCdlbGVtZW50IGhvb2tzJywgZnVuY3Rpb24oKSB7XG4gICAgICBpdCgnY2FsbHMgYGNyZWF0ZWAgbGlzdGVuZXIgYmVmb3JlIGluc2VydGVkIGludG8gcGFyZW50IGJ1dCBhZnRlciBjaGlsZHJlbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGNiKGVtcHR5LCB2bm9kZSkge1xuICAgICAgICAgIGFzc2VydCh2bm9kZS5lbG0gaW5zdGFuY2VvZiBFbGVtZW50KTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwodm5vZGUuZWxtLmNoaWxkcmVuLmxlbmd0aCwgMik7XG4gICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHZub2RlLmVsbS5wYXJlbnROb2RlLCBudWxsKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZub2RlMSA9IGgoJ2RpdicsIFtcbiAgICAgICAgICBoKCdzcGFuJywgJ0ZpcnN0IHNpYmxpbmcnKSxcbiAgICAgICAgICBoKCdkaXYnLCB7aG9vazoge2NyZWF0ZTogY2J9fSwgW1xuICAgICAgICAgICAgaCgnc3BhbicsICdDaGlsZCAxJyksXG4gICAgICAgICAgICBoKCdzcGFuJywgJ0NoaWxkIDInKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBoKCdzcGFuJywgJ0NhblxcJ3QgdG91Y2ggbWUnKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKDEsIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgICBpdCgnY2FsbHMgYGluc2VydGAgbGlzdGVuZXIgYWZ0ZXIgYm90aCBwYXJlbnRzLCBzaWJsaW5ncyBhbmQgY2hpbGRyZW4gaGF2ZSBiZWVuIGluc2VydGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gY2Iodm5vZGUpIHtcbiAgICAgICAgICBhc3NlcnQodm5vZGUuZWxtIGluc3RhbmNlb2YgRWxlbWVudCk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKHZub2RlLmVsbS5jaGlsZHJlbi5sZW5ndGgsIDIpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbCh2bm9kZS5lbG0ucGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGgsIDMpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW1xuICAgICAgICAgIGgoJ3NwYW4nLCAnRmlyc3Qgc2libGluZycpLFxuICAgICAgICAgIGgoJ2RpdicsIHtob29rOiB7aW5zZXJ0OiBjYn19LCBbXG4gICAgICAgICAgICBoKCdzcGFuJywgJ0NoaWxkIDEnKSxcbiAgICAgICAgICAgIGgoJ3NwYW4nLCAnQ2hpbGQgMicpLFxuICAgICAgICAgIF0pLFxuICAgICAgICAgIGgoJ3NwYW4nLCAnQ2FuIHRvdWNoIG1lJyksXG4gICAgICAgIF0pO1xuICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgIGFzc2VydC5lcXVhbCgxLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ2NhbGxzIGBwcmVwYXRjaGAgbGlzdGVuZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBjYihvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwob2xkVm5vZGUsIHZub2RlMS5jaGlsZHJlblsxXSk7XG4gICAgICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHZub2RlLCB2bm9kZTIuY2hpbGRyZW5bMV0pO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW1xuICAgICAgICAgIGgoJ3NwYW4nLCAnRmlyc3Qgc2libGluZycpLFxuICAgICAgICAgIGgoJ2RpdicsIHtob29rOiB7cHJlcGF0Y2g6IGNifX0sIFtcbiAgICAgICAgICAgIGgoJ3NwYW4nLCAnQ2hpbGQgMScpLFxuICAgICAgICAgICAgaCgnc3BhbicsICdDaGlsZCAyJyksXG4gICAgICAgICAgXSksXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW1xuICAgICAgICAgIGgoJ3NwYW4nLCAnRmlyc3Qgc2libGluZycpLFxuICAgICAgICAgIGgoJ2RpdicsIHtob29rOiB7cHJlcGF0Y2g6IGNifX0sIFtcbiAgICAgICAgICAgIGgoJ3NwYW4nLCAnQ2hpbGQgMScpLFxuICAgICAgICAgICAgaCgnc3BhbicsICdDaGlsZCAyJyksXG4gICAgICAgICAgXSksXG4gICAgICAgIF0pO1xuICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdC5sZW5ndGgsIDEpO1xuICAgICAgfSk7XG4gICAgICBpdCgnY2FsbHMgYHBvc3RwYXRjaGAgYWZ0ZXIgYHByZXBhdGNoYCBsaXN0ZW5lcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJlID0gW10sIHBvc3QgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gcHJlQ2Iob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgICAgcHJlLnB1c2gocHJlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwb3N0Q2Iob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKHByZS5sZW5ndGgsIHBvc3QubGVuZ3RoICsgMSk7XG4gICAgICAgICAgcG9zdC5wdXNoKHBvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2bm9kZTEgPSBoKCdkaXYnLCBbXG4gICAgICAgICAgaCgnc3BhbicsICdGaXJzdCBzaWJsaW5nJyksXG4gICAgICAgICAgaCgnZGl2Jywge2hvb2s6IHtwcmVwYXRjaDogcHJlQ2IsIHBvc3RwYXRjaDogcG9zdENifX0sIFtcbiAgICAgICAgICAgIGgoJ3NwYW4nLCAnQ2hpbGQgMScpLFxuICAgICAgICAgICAgaCgnc3BhbicsICdDaGlsZCAyJyksXG4gICAgICAgICAgXSksXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW1xuICAgICAgICAgIGgoJ3NwYW4nLCAnRmlyc3Qgc2libGluZycpLFxuICAgICAgICAgIGgoJ2RpdicsIHtob29rOiB7cHJlcGF0Y2g6IHByZUNiLCBwb3N0cGF0Y2g6IHBvc3RDYn19LCBbXG4gICAgICAgICAgICBoKCdzcGFuJywgJ0NoaWxkIDEnKSxcbiAgICAgICAgICAgIGgoJ3NwYW4nLCAnQ2hpbGQgMicpLFxuICAgICAgICAgIF0pLFxuICAgICAgICBdKTtcbiAgICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgIGFzc2VydC5lcXVhbChwcmUubGVuZ3RoLCAxKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHBvc3QubGVuZ3RoLCAxKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ2NhbGxzIGB1cGRhdGVgIGxpc3RlbmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQxID0gW107XG4gICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGNiKHJlc3VsdCwgb2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRbcmVzdWx0Lmxlbmd0aC0xXSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhvbGRWbm9kZSk7XG4gICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocmVzdWx0W3Jlc3VsdC5sZW5ndGgtMV0sIG9sZFZub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2bm9kZTEgPSBoKCdkaXYnLCBbXG4gICAgICAgICAgaCgnc3BhbicsICdGaXJzdCBzaWJsaW5nJyksXG4gICAgICAgICAgaCgnZGl2Jywge2hvb2s6IHt1cGRhdGU6IGNiLmJpbmQobnVsbCwgcmVzdWx0MSl9fSwgW1xuICAgICAgICAgICAgaCgnc3BhbicsICdDaGlsZCAxJyksXG4gICAgICAgICAgICBoKCdzcGFuJywge2hvb2s6IHt1cGRhdGU6IGNiLmJpbmQobnVsbCwgcmVzdWx0Mil9fSwgJ0NoaWxkIDInKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciB2bm9kZTIgPSBoKCdkaXYnLCBbXG4gICAgICAgICAgaCgnc3BhbicsICdGaXJzdCBzaWJsaW5nJyksXG4gICAgICAgICAgaCgnZGl2Jywge2hvb2s6IHt1cGRhdGU6IGNiLmJpbmQobnVsbCwgcmVzdWx0MSl9fSwgW1xuICAgICAgICAgICAgaCgnc3BhbicsICdDaGlsZCAxJyksXG4gICAgICAgICAgICBoKCdzcGFuJywge2hvb2s6IHt1cGRhdGU6IGNiLmJpbmQobnVsbCwgcmVzdWx0Mil9fSwgJ0NoaWxkIDInKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgICAgICBhc3NlcnQuZXF1YWwocmVzdWx0MS5sZW5ndGgsIDEpO1xuICAgICAgICBhc3NlcnQuZXF1YWwocmVzdWx0Mi5sZW5ndGgsIDEpO1xuICAgICAgfSk7XG4gICAgICBpdCgnY2FsbHMgYHJlbW92ZWAgbGlzdGVuZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBjYih2bm9kZSwgcm0pIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gdm5vZGUuZWxtLnBhcmVudE5vZGU7XG4gICAgICAgICAgYXNzZXJ0KHZub2RlLmVsbSBpbnN0YW5jZW9mIEVsZW1lbnQpO1xuICAgICAgICAgIGFzc2VydC5lcXVhbCh2bm9kZS5lbG0uY2hpbGRyZW4ubGVuZ3RoLCAyKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwocGFyZW50LmNoaWxkcmVuLmxlbmd0aCwgMik7XG4gICAgICAgICAgcmVzdWx0LnB1c2godm5vZGUpO1xuICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgYXNzZXJ0LmVxdWFsKHBhcmVudC5jaGlsZHJlbi5sZW5ndGgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2bm9kZTEgPSBoKCdkaXYnLCBbXG4gICAgICAgICAgaCgnc3BhbicsICdGaXJzdCBzaWJsaW5nJyksXG4gICAgICAgICAgaCgnZGl2Jywge2hvb2s6IHtyZW1vdmU6IGNifX0sIFtcbiAgICAgICAgICAgIGgoJ3NwYW4nLCAnQ2hpbGQgMScpLFxuICAgICAgICAgICAgaCgnc3BhbicsICdDaGlsZCAyJyksXG4gICAgICAgICAgXSksXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW1xuICAgICAgICAgIGgoJ3NwYW4nLCAnRmlyc3Qgc2libGluZycpLFxuICAgICAgICBdKTtcbiAgICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICAgIGFzc2VydC5lcXVhbCgxLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ3JlbW92ZXMgZWxlbWVudCB3aGVuIGFsbCByZW1vdmUgbGlzdGVuZXJzIGFyZSBkb25lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBybTEsIHJtMiwgcm0zO1xuICAgICAgICB2YXIgcGF0Y2ggPSBzbmFiYmRvbS5pbml0KFtcbiAgICAgICAgICB7cmVtb3ZlOiBmdW5jdGlvbihfLCBybSkgeyBybTEgPSBybTsgfX0sXG4gICAgICAgICAge3JlbW92ZTogZnVuY3Rpb24oXywgcm0pIHsgcm0yID0gcm07IH19LFxuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHZub2RlMSA9IGgoJ2RpdicsIFtoKCdhJywge2hvb2s6IHtyZW1vdmU6IGZ1bmN0aW9uKF8sIHJtKSB7IHJtMyA9IHJtOyB9fX0pXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGVsbS5jaGlsZHJlbi5sZW5ndGgsIDEpO1xuICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCAxKTtcbiAgICAgICAgcm0xKCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCAxKTtcbiAgICAgICAgcm0zKCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCAxKTtcbiAgICAgICAgcm0yKCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChlbG0uY2hpbGRyZW4ubGVuZ3RoLCAwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCdtb2R1bGUgaG9va3MnLCBmdW5jdGlvbigpIHtcbiAgICAgIGl0KCdpbnZva2VzIGBwcmVgIGFuZCBgcG9zdGAgaG9vaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBwYXRjaCA9IHNuYWJiZG9tLmluaXQoW1xuICAgICAgICAgIHtwcmU6IGZ1bmN0aW9uKCkgeyByZXN1bHQucHVzaCgncHJlJyk7IH19LFxuICAgICAgICAgIHtwb3N0OiBmdW5jdGlvbigpIHsgcmVzdWx0LnB1c2goJ3Bvc3QnKTsgfX0sXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2Jyk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChyZXN1bHQsIFsncHJlJywgJ3Bvc3QnXSk7XG4gICAgICB9KTtcbiAgICAgIGl0KCdpbnZva2VzIGdsb2JhbCBgZGVzdHJveWAgaG9vayBmb3IgYWxsIHJlbW92ZWQgY2hpbGRyZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBjYih2bm9kZSkgeyByZXN1bHQucHVzaCh2bm9kZSk7IH1cbiAgICAgICAgdmFyIHZub2RlMSA9IGgoJ2RpdicsIFtcbiAgICAgICAgICBoKCdzcGFuJywgJ0ZpcnN0IHNpYmxpbmcnKSxcbiAgICAgICAgICBoKCdkaXYnLCBbXG4gICAgICAgICAgICBoKCdzcGFuJywge2hvb2s6IHtkZXN0cm95OiBjYn19LCAnQ2hpbGQgMScpLFxuICAgICAgICAgICAgaCgnc3BhbicsICdDaGlsZCAyJyksXG4gICAgICAgICAgXSksXG4gICAgICAgIF0pO1xuICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUwKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdC5sZW5ndGgsIDEpO1xuICAgICAgfSk7XG4gICAgICBpdCgnaGFuZGxlcyB0ZXh0IHZub2RlcyB3aXRoIGB1bmRlZmluZWRgIGBkYXRhYCBwcm9wZXJ0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW1xuICAgICAgICAgICcgJ1xuICAgICAgICBdKTtcbiAgICAgICAgdmFyIHZub2RlMiA9IGgoJ2RpdicsIFtdKTtcbiAgICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgICAgICBwYXRjaCh2bm9kZTEsIHZub2RlMik7XG4gICAgICB9KTtcbiAgICAgIGl0KCdpbnZva2VzIGBkZXN0cm95YCBtb2R1bGUgaG9vayBmb3IgYWxsIHJlbW92ZWQgY2hpbGRyZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNyZWF0ZWQgPSAwO1xuICAgICAgICB2YXIgZGVzdHJveWVkID0gMDtcbiAgICAgICAgdmFyIHBhdGNoID0gc25hYmJkb20uaW5pdChbXG4gICAgICAgICAge2NyZWF0ZTogZnVuY3Rpb24oKSB7IGNyZWF0ZWQrKzsgfX0sXG4gICAgICAgICAge2Rlc3Ryb3k6IGZ1bmN0aW9uKCkgeyBkZXN0cm95ZWQrKzsgfX0sXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW1xuICAgICAgICAgIGgoJ3NwYW4nLCAnRmlyc3Qgc2libGluZycpLFxuICAgICAgICAgIGgoJ2RpdicsIFtcbiAgICAgICAgICAgIGgoJ3NwYW4nLCAnQ2hpbGQgMScpLFxuICAgICAgICAgICAgaCgnc3BhbicsICdDaGlsZCAyJyksXG4gICAgICAgICAgXSksXG4gICAgICAgIF0pO1xuICAgICAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUwKTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKGNyZWF0ZWQsIDQpO1xuICAgICAgICBhc3NlcnQuZXF1YWwoZGVzdHJveWVkLCA0KTtcbiAgICAgIH0pO1xuICAgICAgaXQoJ2RvZXMgbm90IGludm9rZSBgZGVzdHJveWAgbW9kdWxlIGhvb2sgZm9yIHRleHQgbm9kZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNyZWF0ZWQgPSAwO1xuICAgICAgICB2YXIgZGVzdHJveWVkID0gMDtcbiAgICAgICAgdmFyIHBhdGNoID0gc25hYmJkb20uaW5pdChbXG4gICAgICAgICAge2NyZWF0ZTogZnVuY3Rpb24oKSB7IGNyZWF0ZWQrKzsgfX0sXG4gICAgICAgICAge2Rlc3Ryb3k6IGZ1bmN0aW9uKCkgeyBkZXN0cm95ZWQrKzsgfX0sXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW1xuICAgICAgICAgIGgoJ3NwYW4nLCAnRmlyc3Qgc2libGluZycpLFxuICAgICAgICAgIGgoJ2RpdicsIFtcbiAgICAgICAgICAgIGgoJ3NwYW4nLCAnQ2hpbGQgMScpLFxuICAgICAgICAgICAgaCgnc3BhbicsIFsnVGV4dCAxJywgJ1RleHQgMiddKSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTApO1xuICAgICAgICBhc3NlcnQuZXF1YWwoY3JlYXRlZCwgNCk7XG4gICAgICAgIGFzc2VydC5lcXVhbChkZXN0cm95ZWQsIDQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICBkZXNjcmliZSgnc2hvcnQgY2lyY3VpdGluZycsIGZ1bmN0aW9uKCkge1xuICAgIGl0KCdkb2VzIG5vdCB1cGRhdGUgc3RyaWN0bHkgZXF1YWwgdm5vZGVzJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmdW5jdGlvbiBjYih2bm9kZSkgeyByZXN1bHQucHVzaCh2bm9kZSk7IH1cbiAgICAgIHZhciB2bm9kZTEgPSBoKCdkaXYnLCBbXG4gICAgICAgIGgoJ3NwYW4nLCB7aG9vazoge3VwZGF0ZTogY2J9fSwgJ0hlbGxvJyksXG4gICAgICAgIGgoJ3NwYW4nLCAndGhlcmUnKSxcbiAgICAgIF0pO1xuICAgICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgICAgcGF0Y2godm5vZGUxLCB2bm9kZTEpO1xuICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdC5sZW5ndGgsIDApO1xuICAgIH0pO1xuICAgIGl0KCdkb2VzIG5vdCB1cGRhdGUgc3RyaWN0bHkgZXF1YWwgY2hpbGRyZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGNiKHZub2RlKSB7IHJlc3VsdC5wdXNoKHZub2RlKTsgfVxuICAgICAgdmFyIHZub2RlMSA9IGgoJ2RpdicsIFtcbiAgICAgICAgaCgnc3BhbicsIHtob29rOiB7cGF0Y2g6IGNifX0sICdIZWxsbycpLFxuICAgICAgICBoKCdzcGFuJywgJ3RoZXJlJyksXG4gICAgICBdKTtcbiAgICAgIHZhciB2bm9kZTIgPSBoKCdkaXYnKTtcbiAgICAgIHZub2RlMi5jaGlsZHJlbiA9IHZub2RlMS5jaGlsZHJlbjtcbiAgICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICAgIGFzc2VydC5lcXVhbChyZXN1bHQubGVuZ3RoLCAwKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiIsInJlcXVpcmUoJy4vY29yZScpO1xucmVxdWlyZSgnLi9zdHlsZScpO1xucmVxdWlyZSgnLi9hdHRhY2h0bycpO1xucmVxdWlyZSgnLi90aHVuaycpO1xuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIGZha2VSYWYgPSByZXF1aXJlKCdmYWtlLXJhZicpO1xuXG52YXIgc25hYmJkb20gPSByZXF1aXJlKCcuLi9zbmFiYmRvbScpO1xuZmFrZVJhZi51c2UoKTtcbnZhciBwYXRjaCA9IHNuYWJiZG9tLmluaXQoW1xuICByZXF1aXJlKCcuLi9tb2R1bGVzL3N0eWxlJyksXG5dKTtcbnZhciBoID0gcmVxdWlyZSgnLi4vaCcpO1xuXG5kZXNjcmliZSgnc3R5bGUnLCBmdW5jdGlvbigpIHtcbiAgdmFyIGVsbSwgdm5vZGUwO1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZub2RlMCA9IGVsbTtcbiAgfSk7XG4gIGl0KCdpcyBiZWluZyBzdHlsZWQnLCBmdW5jdGlvbigpIHtcbiAgICBwYXRjaCh2bm9kZTAsIGgoJ2RpdicsIHtzdHlsZToge2ZvbnRTaXplOiAnMTJweCd9fSkpO1xuICAgIGFzc2VydC5lcXVhbChlbG0uc3R5bGUuZm9udFNpemUsICcxMnB4Jyk7XG4gIH0pO1xuICBpdCgndXBkYXRlcyBzdHlsZXMnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdm5vZGUxID0gaCgnaScsIHtzdHlsZToge2ZvbnRTaXplOiAnMTRweCcsIGRpc3BsYXk6ICdpbmxpbmUnfX0pO1xuICAgIHZhciB2bm9kZTIgPSBoKCdpJywge3N0eWxlOiB7Zm9udFNpemU6ICcxMnB4JywgZGlzcGxheTogJ2Jsb2NrJ319KTtcbiAgICB2YXIgdm5vZGUzID0gaCgnaScsIHtzdHlsZToge2ZvbnRTaXplOiAnMTBweCcsIGRpc3BsYXk6ICdibG9jayd9fSk7XG4gICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgIGFzc2VydC5lcXVhbChlbG0uc3R5bGUuZm9udFNpemUsICcxNHB4Jyk7XG4gICAgYXNzZXJ0LmVxdWFsKGVsbS5zdHlsZS5kaXNwbGF5LCAnaW5saW5lJyk7XG4gICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgIGFzc2VydC5lcXVhbChlbG0uc3R5bGUuZm9udFNpemUsICcxMnB4Jyk7XG4gICAgYXNzZXJ0LmVxdWFsKGVsbS5zdHlsZS5kaXNwbGF5LCAnYmxvY2snKTtcbiAgICBwYXRjaCh2bm9kZTIsIHZub2RlMyk7XG4gICAgYXNzZXJ0LmVxdWFsKGVsbS5zdHlsZS5mb250U2l6ZSwgJzEwcHgnKTtcbiAgICBhc3NlcnQuZXF1YWwoZWxtLnN0eWxlLmRpc3BsYXksICdibG9jaycpO1xuICB9KTtcbiAgaXQoJ3VwZGF0ZXMgZGVsYXllZCBzdHlsZXMgaW4gbmV4dCBmcmFtZScsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXRjaCA9IHNuYWJiZG9tLmluaXQoW1xuICAgICAgcmVxdWlyZSgnLi4vbW9kdWxlcy9zdHlsZScpLFxuICAgIF0pO1xuICAgIHZhciB2bm9kZTEgPSBoKCdpJywge3N0eWxlOiB7Zm9udFNpemU6ICcxNHB4JywgZGVsYXllZDoge2ZvbnRTaXplOiAnMTZweCd9fX0pO1xuICAgIHZhciB2bm9kZTIgPSBoKCdpJywge3N0eWxlOiB7Zm9udFNpemU6ICcxOHB4JywgZGVsYXllZDoge2ZvbnRTaXplOiAnMjBweCd9fX0pO1xuICAgIHBhdGNoKHZub2RlMCwgdm5vZGUxKTtcbiAgICBhc3NlcnQuZXF1YWwoZWxtLnN0eWxlLmZvbnRTaXplLCAnMTRweCcpO1xuICAgIGZha2VSYWYuc3RlcCgpO1xuICAgIGZha2VSYWYuc3RlcCgpO1xuICAgIGFzc2VydC5lcXVhbChlbG0uc3R5bGUuZm9udFNpemUsICcxNnB4Jyk7XG4gICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgIGFzc2VydC5lcXVhbChlbG0uc3R5bGUuZm9udFNpemUsICcxOHB4Jyk7XG4gICAgZmFrZVJhZi5zdGVwKCk7XG4gICAgZmFrZVJhZi5zdGVwKCk7XG4gICAgYXNzZXJ0LmVxdWFsKGVsbS5zdHlsZS5mb250U2l6ZSwgJzIwcHgnKTtcbiAgfSk7XG59KTtcblxuZmFrZVJhZi5yZXN0b3JlKCk7XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBzbmFiYmRvbSA9IHJlcXVpcmUoJy4uL3NuYWJiZG9tJyk7XG52YXIgcGF0Y2ggPSBzbmFiYmRvbS5pbml0KFtcbl0pO1xudmFyIGggPSByZXF1aXJlKCcuLi9oJyk7XG52YXIgdGh1bmsgPSByZXF1aXJlKCcuLi90aHVuaycpO1xuXG5kZXNjcmliZSgndGh1bmsnLCBmdW5jdGlvbigpIHtcbiAgdmFyIGVsbSwgdm5vZGUwO1xuICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZub2RlMCA9IGVsbTtcbiAgfSk7XG4gIGl0KCdyZXR1cm5zIHZub2RlIHdpdGggZGF0YSBhbmQgcmVuZGVyIGZ1bmN0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gbnVtYmVySW5TcGFuKG4pIHtcbiAgICAgIHJldHVybiBoKCdzcGFuJywgJ051bWJlciBpcyAnICsgbik7XG4gICAgfVxuICAgIHZhciB2bm9kZSA9IHRodW5rKCdudW0nLCBudW1iZXJJblNwYW4sIDIyKTtcbiAgICBhc3NlcnQuZGVlcEVxdWFsKHZub2RlLnNlbCwgJ3RodW5rbnVtJyk7XG4gICAgYXNzZXJ0LmRlZXBFcXVhbCh2bm9kZS5kYXRhLmFyZ3MsIFsyMl0pO1xuICB9KTtcbiAgaXQoJ29ubHkgY2FsbHMgcmVuZGVyIGZ1bmN0aW9uIG9uIGRhdGEgY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgZnVuY3Rpb24gbnVtYmVySW5TcGFuKG4pIHtcbiAgICAgIGNhbGxlZCsrO1xuICAgICAgcmV0dXJuIGgoJ3NwYW4nLCAnTnVtYmVyIGlzICcgKyBuKTtcbiAgICB9XG4gICAgdmFyIHZub2RlMSA9IGgoJ2RpdicsIFtcbiAgICAgIHRodW5rKCdudW0nLCBudW1iZXJJblNwYW4sIDEpXG4gICAgXSk7XG4gICAgdmFyIHZub2RlMiA9IGgoJ2RpdicsIFtcbiAgICAgIHRodW5rKCdudW0nLCBudW1iZXJJblNwYW4sIDEpXG4gICAgXSk7XG4gICAgdmFyIHZub2RlMyA9IGgoJ2RpdicsIFtcbiAgICAgIHRodW5rKCdudW0nLCBudW1iZXJJblNwYW4sIDIpXG4gICAgXSk7XG4gICAgcGF0Y2godm5vZGUwLCB2bm9kZTEpO1xuICAgIHBhdGNoKHZub2RlMSwgdm5vZGUyKTtcbiAgICBwYXRjaCh2bm9kZTIsIHZub2RlMyk7XG4gICAgYXNzZXJ0LmVxdWFsKGNhbGxlZCwgMik7XG4gIH0pO1xuICBpdCgncmVuZGVycyBjb3JyZWN0bHknLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FsbGVkID0gMDtcbiAgICBmdW5jdGlvbiBudW1iZXJJblNwYW4obikge1xuICAgICAgY2FsbGVkKys7XG4gICAgICByZXR1cm4gaCgnc3BhbicsICdOdW1iZXIgaXMgJyArIG4pO1xuICAgIH1cbiAgICB2YXIgdm5vZGUxID0gaCgnZGl2JywgW1xuICAgICAgdGh1bmsoJ251bScsIG51bWJlckluU3BhbiwgMSlcbiAgICBdKTtcbiAgICB2YXIgdm5vZGUyID0gaCgnZGl2JywgW1xuICAgICAgdGh1bmsoJ251bScsIG51bWJlckluU3BhbiwgMSlcbiAgICBdKTtcbiAgICB2YXIgdm5vZGUzID0gaCgnZGl2JywgW1xuICAgICAgdGh1bmsoJ251bScsIG51bWJlckluU3BhbiwgMilcbiAgICBdKTtcbiAgICBwYXRjaCh2bm9kZTAsIHZub2RlMSk7XG4gICAgYXNzZXJ0LmVxdWFsKGVsbS5maXJzdENoaWxkLmlubmVySFRNTCwgJ051bWJlciBpcyAxJyk7XG4gICAgcGF0Y2godm5vZGUxLCB2bm9kZTIpO1xuICAgIGFzc2VydC5lcXVhbChlbG0uZmlyc3RDaGlsZC5pbm5lckhUTUwsICdOdW1iZXIgaXMgMScpO1xuICAgIHBhdGNoKHZub2RlMiwgdm5vZGUzKTtcbiAgICBhc3NlcnQuZXF1YWwoZWxtLmZpcnN0Q2hpbGQuaW5uZXJIVE1MLCAnTnVtYmVyIGlzIDInKTtcbiAgICBhc3NlcnQuZXF1YWwoY2FsbGVkLCAyKTtcbiAgfSk7XG59KTtcbiIsInZhciBoID0gcmVxdWlyZSgnLi9oJyk7XG5cbmZ1bmN0aW9uIGluaXQodGh1bmspIHtcbiAgdmFyIGksIGN1ciA9IHRodW5rLmRhdGE7XG4gIGN1ci52bm9kZSA9IGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGN1ci5hcmdzKTtcbn1cblxuZnVuY3Rpb24gcHJlcGF0Y2gob2xkVGh1bmssIHRodW5rKSB7XG4gIHZhciBpLCBvbGQgPSBvbGRUaHVuay5kYXRhLCBjdXIgPSB0aHVuay5kYXRhO1xuICB2YXIgb2xkQXJncyA9IG9sZC5hcmdzLCBhcmdzID0gY3VyLmFyZ3M7XG4gIGN1ci52bm9kZSA9IG9sZC52bm9kZTtcbiAgaWYgKG9sZEFyZ3MubGVuZ3RoICE9PSBhcmdzLmxlbmd0aCkge1xuICAgIGN1ci52bm9kZSA9IGN1ci5mbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChvbGRBcmdzW2ldICE9PSBhcmdzW2ldKSB7XG4gICAgICBjdXIudm5vZGUgPSBjdXIuZm4uYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lLCBmbiAvKiBhcmdzICovKSB7XG4gIHZhciBpLCBhcmdzID0gW107XG4gIGZvciAoaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzW2kgLSAyXSA9IGFyZ3VtZW50c1tpXTtcbiAgfVxuICByZXR1cm4gaCgndGh1bmsnICsgbmFtZSwge1xuICAgIGhvb2s6IHtpbml0OiBpbml0LCBwcmVwYXRjaDogcHJlcGF0Y2h9LFxuICAgIGZuOiBmbiwgYXJnczogYXJncyxcbiAgfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzZWwsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCBlbG0pIHtcbiAgdmFyIGtleSA9IGRhdGEgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGRhdGEua2V5O1xuICByZXR1cm4ge3NlbDogc2VsLCBkYXRhOiBkYXRhLCBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgdGV4dDogdGV4dCwgZWxtOiBlbG0sIGtleToga2V5fTtcbn07XG4iLCIvLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gd2hlbiB1c2VkIGluIG5vZGUsIHRoaXMgd2lsbCBhY3R1YWxseSBsb2FkIHRoZSB1dGlsIG1vZHVsZSB3ZSBkZXBlbmQgb25cbi8vIHZlcnN1cyBsb2FkaW5nIHRoZSBidWlsdGluIHV0aWwgbW9kdWxlIGFzIGhhcHBlbnMgb3RoZXJ3aXNlXG4vLyB0aGlzIGlzIGEgYnVnIGluIG5vZGUgbW9kdWxlIGxvYWRpbmcgYXMgZmFyIGFzIEkgYW0gY29uY2VybmVkXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG5cbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gc3RhY2tTdGFydEZ1bmN0aW9uLm5hbWU7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIGlmICh1dGlsLmlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgIHJldHVybiAnJyArIHZhbHVlO1xuICB9XG4gIGlmICh1dGlsLmlzTnVtYmVyKHZhbHVlKSAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbih2YWx1ZSkgfHwgdXRpbC5pc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocykpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeShzZWxmLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5leHBlY3RlZCwgcmVwbGFjZXIpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmICh1dGlsLmlzQnVmZmVyKGFjdHVhbCkgJiYgdXRpbC5pc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICBpZiAoYWN0dWFsLmxlbmd0aCAhPSBleHBlY3RlZC5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0dWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0dWFsW2ldICE9PSBleHBlY3RlZFtpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICghdXRpbC5pc09iamVjdChhY3R1YWwpICYmICF1dGlsLmlzT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAodXRpbC5pc051bGxPclVuZGVmaW5lZChhKSB8fCB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LlxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSByZXR1cm4gZmFsc2U7XG4gIC8vfn5+SSd2ZSBtYW5hZ2VkIHRvIGJyZWFrIE9iamVjdC5rZXlzIHRocm91Z2ggc2NyZXd5IGFyZ3VtZW50cyBwYXNzaW5nLlxuICAvLyAgIENvbnZlcnRpbmcgdG8gYXJyYXkgc29sdmVzIHRoZSBwcm9ibGVtLlxuICBpZiAoaXNBcmd1bWVudHMoYSkpIHtcbiAgICBpZiAoIWlzQXJndW1lbnRzKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBvYmplY3RLZXlzKGEpLFxuICAgICAgICBrYiA9IG9iamVjdEtleXMoYiksXG4gICAgICAgIGtleSwgaTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoZXhwZWN0ZWQpKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGFjdHVhbCA9IGU7XG4gIH1cblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICghc2hvdWxkVGhyb3cgJiYgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW3RydWVdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFtmYWxzZV0uY29uY2F0KHBTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHt0aHJvdyBlcnI7fX07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5NdXRhdGlvbk9ic2VydmVyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBbXTtcblxuICAgIGlmIChjYW5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVldWVMaXN0ID0gcXVldWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBxdWV1ZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoaGlkZGVuRGl2LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5zZXRBdHRyaWJ1dGUoJ3llcycsICdubycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSJdfQ==
